<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>谷涧月的学习流水账</title>

  
  <meta name="author" content="谷涧月">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="谷涧月的学习流水账"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="谷涧月的学习流水账" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">谷涧月的学习流水账</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2024/12/26/服务器性能指标过载排查思路/"><span>服务器性能指标过载排查思路</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/26/服务器性能指标过载排查思路/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-26T13:28:52.000Z">
          2024-12-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>当 Linux 服务器 的 CPU、内存 或 网络 出现过载时，通常意味着系统正在面临资源瓶颈或异常行为。为了排查这个问题，需要通过一系列的系统工具和方法来诊断和识别瓶颈的根本原因。以下是一些常见的排查步骤：</p>
<ol>
<li>检查 CPU 使用情况</li>
</ol>
<p>查看整体 CPU 使用情况：<br>    •	使用 top 或 htop 命令查看当前系统的 CPU 使用率。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p>htop 提供了更加友好的界面，可以使用它来动态地查看 CPU 负载。<br>    •	%us：用户空间的 CPU 使用比例<br>    •	%sy：内核空间的 CPU 使用比例<br>    •	%id：空闲 CPU 时间<br>    •	%wa：等待 I&#x2F;O 的 CPU 时间<br>    •	%st：虚拟机偷取的 CPU 时间</p>
<p>查看每个进程的 CPU 使用情况：<br>    •	使用 top 或 ps 命令查看当前占用 CPU 的进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -o %CPU</span><br></pre></td></tr></table></figure>
<p>或者使用 ps 列出占用 CPU 的进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --<span class="built_in">sort</span>=-%cpu | <span class="built_in">head</span> -n 10</span><br></pre></td></tr></table></figure>


<p>检查是否有进程陷入 无响应状态：<br>    •	如果进程处于 D（uninterruptible sleep） 状态，表示它在等待 I&#x2F;O 操作完成，可能导致 CPU 被阻塞。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27; D &#x27;</span></span><br></pre></td></tr></table></figure>


<p>检查系统负载（load average）：<br>    •	使用 uptime 或 top 命令查看系统负载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br></pre></td></tr></table></figure>
<p>负载均衡值（load average）显示的是在过去 1 分钟、5 分钟和 15 分钟内的平均进程数。高负载可能意味着系统 CPU 资源紧张。</p>
<ol start="2">
<li>检查内存使用情况</li>
</ol>
<p>使用 free 命令查看内存使用：<br>    •	free -m 可以查看系统内存的使用情况（单位是 MB）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
<pre><code>•	Mem：总内存、已用内存、剩余内存。
•	Swap：交换分区的使用情况。高 swap 使用可能意味着物理内存不足，导致系统频繁交换数据到磁盘。
</code></pre>
<p>检查进程的内存占用情况：<br>    •	使用 top 或 ps 命令查看占用内存最多的进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -o %MEM</span><br></pre></td></tr></table></figure>
<p>或者使用 ps 查看内存使用最多的进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --<span class="built_in">sort</span>=-%mem | <span class="built_in">head</span> -n 10</span><br></pre></td></tr></table></figure>


<p>检查是否有 内存泄漏：<br>    •	如果系统的可用内存持续下降，可以使用 smem（或者 pmap）查看各个进程的内存使用情况，排查是否有内存泄漏。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smem -r</span><br></pre></td></tr></table></figure>


<p>使用 vmstat 查看虚拟内存情况：<br>    •	vmstat 提供了系统的内存、交换区、I&#x2F;O、进程、CPU 等信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat 1</span><br></pre></td></tr></table></figure>
<pre><code>•	si 和 so 分别表示交换内存的输入和输出。高交换活动通常意味着物理内存不足。
</code></pre>
<p>检查内存是否有 OOM（Out of Memory） 错误：<br>    •	如果系统没有足够的内存，它可能会启动 OOM Killer 来终止一些进程以释放内存。可以通过查看 &#x2F;var&#x2F;log&#x2F;messages 或 &#x2F;var&#x2F;log&#x2F;syslog 日志文件来确认是否发生了 OOM 错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/syslog | grep -i <span class="string">&quot;out of memory&quot;</span></span><br></pre></td></tr></table></figure>


<ol start="3">
<li>检查网络使用情况</li>
</ol>
<p>使用 netstat 或 ss 查看网络连接：<br>    •	netstat 或 ss 可以查看当前的网络连接及其状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tuln</span><br></pre></td></tr></table></figure>
<pre><code>•	通过 -t 查看 TCP 连接，-u 查看 UDP 连接，-l 查看正在监听的端口，-n 显示数字格式。
</code></pre>
<p>检查网络带宽使用情况：<br>    •	使用 iftop 或 nload 监控网络流量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iftop</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nload</span><br></pre></td></tr></table></figure>
<p>这些工具可以帮助你实时查看每个连接的流量情况，找出是否存在异常的流量高峰。</p>
<p>检查 TCP 状态：<br>    •	使用 ss 查看 TCP 连接的状态，查找是否存在大量的 TIME_WAIT 或 CLOSE_WAIT 状态的连接，可能意味着有大量的关闭连接或连接未正常关闭。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -s</span><br></pre></td></tr></table></figure>
<p>你可以检查 TIME_WAIT 和 CLOSE_WAIT 状态，如果这些连接积压过多，可能导致网络性能下降。</p>
<p>网络丢包或延迟：<br>    •	使用 ping 测试到其他主机的连通性，检查是否有丢包现象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 10 &lt;destination_ip&gt;</span><br></pre></td></tr></table></figure>
<p>你可以查看是否存在高延迟或丢包，丢包可能指示网络硬件或带宽问题。</p>
<ol start="4">
<li>检查磁盘 I&#x2F;O 使用情况</li>
</ol>
<p>使用 iostat 查看磁盘 I&#x2F;O 情况：<br>    •	使用 iostat 检查磁盘的读取&#x2F;写入情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x 1</span><br></pre></td></tr></table></figure>
<pre><code>•	%util：磁盘利用率，如果值接近 100%，表示磁盘繁忙。
•	await：磁盘操作的平均等待时间，较高的 await 值可能表示磁盘性能瓶颈。
</code></pre>
<p>使用 dstat 或 iotop 监控磁盘 I&#x2F;O：<br>    •	dstat 或 iotop 可以显示实时的磁盘 I&#x2F;O 使用情况，帮助你定位是否有某些进程正在占用大量磁盘 I&#x2F;O。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -cdlmn</span><br></pre></td></tr></table></figure>
<p>或者使用 iotop：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iotop</span><br></pre></td></tr></table></figure>


<ol start="5">
<li><p>分析日志文件<br> •	查看 &#x2F;var&#x2F;log&#x2F;syslog、&#x2F;var&#x2F;log&#x2F;messages、&#x2F;var&#x2F;log&#x2F;dmesg 等系统日志，可能会有有关硬件故障、磁盘问题或其他异常行为的警告或错误信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/syslog | grep -i <span class="string">&quot;error&quot;</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/messages | grep -i <span class="string">&quot;error&quot;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>其他工具<br> •	sar（System Activity Reporter）：可以查看过去的系统性能数据，帮助你发现历史上的问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sar -u 1 3  <span class="comment"># 查看 CPU 使用情况</span></span><br><span class="line">sar -r 1 3  <span class="comment"># 查看内存使用情况</span></span><br></pre></td></tr></table></figure>

<p> •	dmesg：检查内核日志，查看是否有硬件故障或内存错误。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i error</span><br></pre></td></tr></table></figure>


<p>总结</p>
<p>当 Linux 服务器出现 CPU、内存或网络过载时，需要结合多种工具来诊断问题。通过 top&#x2F;htop 查看 CPU 和进程状态，使用 free&#x2F;iostat 监控内存和磁盘使用情况，利用 iftop&#x2F;ss 排查网络瓶颈，以及通过日志文件了解系统错误和警告。系统性能问题往往是多因素的，定位问题时需要逐步排查。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Linux/">Linux</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/运维/">运维</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/12/24/如何利用GPU提高程序运算速度/"><span>GPU工作原理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/24/如何利用GPU提高程序运算速度/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-24T09:06:24.000Z">
          2024-12-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="GPU和CPU的区别"><a href="#GPU和CPU的区别" class="headerlink" title="GPU和CPU的区别"></a>GPU和CPU的区别</h2><p><strong>CPU架构设计</strong><br><img src="/../assets/cpu_arch.png" alt="CPU"><br><strong>CPU核心参数</strong><br><img src="/../assets/amd_cpu_bench.png" alt="CPU"><br><strong>GPU架构设计</strong><br><img src="/../assets/gpu_arch.png" alt="GPU"><br><strong>GPU核心参数</strong><br><img src="/../assets/gpu_bench.png" alt="GPU"><br>在CPU的架构中包含多级缓存，各种复杂操作指令集，CPU的架构设计是为了支持复杂的逻辑运算，每个核心都是完整通用的处理器单元，且其工作模式实际上是串行执行任务的，GPU的架构从设计之初就是专门用于处理图像和视频等图形数据,具有大量的流处理器和着色器，且其工作模式是并行执行任务的,从规格也可以看出除了核心数外同期的GPU比CPU有更高的时钟频率和内存带宽。<br>总结下来GPU和CPU的主要区别在以下几点：</p>
<ol>
<li>并行计算能力:<br>GPU：GPU设计为大规模的并行计算，具有数千个小型处理核心，这些核心能够同时执行大量的计算任务。深度学习中的许多计算（如矩阵乘法、卷积运算等）都可以高度并行化。GPU能够同时处理多个数据流（例如，多个神经元的计算），从而大大提高了训练效率。<br>CPU：CPU一般只有少数几个（通常为4到16个）强大的核心，适合处理顺序执行的任务。CPU适合执行需要复杂决策和高频任务的应用，但在深度学习中的大规模矩阵计算、卷积等任务上，其并行能力远逊色于GPU。</li>
<li>内存带宽:<br>GPU：GPU通常配备更宽的内存带宽，允许其快速访问和处理大规模的数据集。例如，现代GPU如NVIDIA的A100、V100、H100等，具有高达1TB&#x2F;s的内存带宽。这使得GPU在处理大规模数据集时能够更快地读取和写入数据，从而提高了训练速度。<br>CPU：虽然CPU的内存带宽也在不断提高，但通常远低于GPU。CPU的内存带宽有限，这使得它在处理深度学习中的大规模数据时，可能成为瓶颈，尤其是对于需要大量数据交换的神经网络模型（如大规模图像、视频处理等）。</li>
</ol>
<h2 id="适合GPU计算的场景"><a href="#适合GPU计算的场景" class="headerlink" title="适合GPU计算的场景"></a>适合GPU计算的场景</h2><ol>
<li>图形渲染和计算机视觉<br>图形渲染：GPU最初的设计目的是加速图形渲染，特别是3D图形。GPU在计算机图形学中通过执行大量并行的图形计算（如光照、阴影、纹理映射等）来加速渲染过程。<br>应用：视频游戏、虚拟现实（VR）、增强现实（AR）、3D建模和动画制作。<br>计算机视觉：GPU可以加速图像处理、目标检测、图像分割、面部识别、自动驾驶汽车中的视觉系统等任务。<br>应用：安防监控、医学影像分析、自动驾驶、工业视觉检测。</li>
<li>大规模矩阵计算<br>GPU：深度学习中的核心任务（如反向传播中的梯度计算和前向传播中的矩阵乘法）是矩阵计算密集型的。GPU特别适合这类任务，因为它能通过并行计算同时处理矩阵中的多个元素。NVIDIA的GPU通过CUDA等库进一步优化了这些运算，使得在训练深度学习模型时，GPU能够极大提升计算效率。<br>CPU：虽然CPU也能进行矩阵计算，但由于缺乏大规模的并行处理能力，CPU在执行大规模矩阵计算时远远不如GPU高效。</li>
<li>自然语言处理（NLP）<br>加速NLP任务：GPU在处理大规模文本数据、训练和推理自然语言处理模型（如Transformer、BERT、GPT等）时表现出色。NLP模型通常需要大量的计算资源来处理文本序列，GPU能够显著加速这些计算。<br>应用：机器翻译、语音识别、聊天机器人、情感分析、文本生成。</li>
<li>医学影像处理<br>CT、MRI图像处理：医学影像处理中常常需要进行大规模的数据分析和图像处理，GPU能够加速图像重建、分割、识别等任务。<br>自动诊断：Nvidia的GPU通过CUDA可以加速基于深度学习的自动化诊断系统，如利用卷积神经网络（CNN）进行肿瘤检测、器官分割等任务。</li>
</ol>
<h2 id="深度学习和神经网络"><a href="#深度学习和神经网络" class="headerlink" title="深度学习和神经网络"></a>深度学习和神经网络</h2><p><strong>深度学习</strong>和<strong>神经网络</strong>是紧密相关的概念，但它们并不完全相同。以下是它们之间的关系及区别：</p>
<h3 id="1-神经网络（Neural-Networks）"><a href="#1-神经网络（Neural-Networks）" class="headerlink" title="1. 神经网络（Neural Networks）"></a>1. <strong>神经网络（Neural Networks）</strong></h3><p>神经网络是模仿生物神经系统的计算模型，尤其是大脑神经元之间的连接结构。在人工智能领域，神经网络被用来进行数据处理和模式识别。</p>
<h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><ul>
<li><strong>神经网络（Neural Network）</strong>：由一组互相连接的节点（即神经元）组成，这些神经元通过权重相连。神经网络可以进行监督学习和非监督学习，用于完成分类、回归等任务。</li>
<li><strong>层次结构</strong>：神经网络通常包含输入层、隐藏层和输出层。每一层包含若干神经元（节点），每个神经元接受前一层的输出，并通过激活函数处理后传递给下一层。</li>
<li><strong>激活函数</strong>：通常使用如ReLU、Sigmoid、Tanh等激活函数来增加网络的非线性能力。</li>
</ul>
<h4 id="传统神经网络（浅层神经网络）："><a href="#传统神经网络（浅层神经网络）：" class="headerlink" title="传统神经网络（浅层神经网络）："></a>传统神经网络（浅层神经网络）：</h4><ul>
<li>神经网络最初并不深，通常只有一层或两层隐藏层（即浅层神经网络）。这些浅层网络对于一些简单的任务（如线性可分问题）效果良好。</li>
<li><strong>不足</strong>：浅层神经网络无法有效地处理复杂、高维的数据和任务（如图像识别、自然语言处理等），并且存在梯度消失和梯度爆炸的问题。</li>
</ul>
<h3 id="2-深度学习"><a href="#2-深度学习" class="headerlink" title="2. 深度学习"></a>2. <strong>深度学习</strong></h3><p>深度学习是神经网络的一种拓展，它指的是具有多个隐藏层（即深层结构）的神经网络模型。深度学习的“深度”通常指的是网络中有多个隐藏层，而这些层次使得模型能够自动学习和提取数据的高级特征。</p>
<h4 id="基本概念：-1"><a href="#基本概念：-1" class="headerlink" title="基本概念："></a>基本概念：</h4><ul>
<li><strong>深度神经网络</strong>：深度学习中的神经网络通常包含很多隐藏层，这些层使得模型能够逐步提取数据的高层次特征。</li>
<li><strong>多层学习</strong>：每一层可以从前一层的输出中学习到更复杂的特征。比如，在图像识别中，浅层可以学习边缘和简单形状，中间层可以学习纹理和局部结构，深层可以学习复杂的对象或场景。</li>
<li><strong>反向传播算法</strong>：深度学习模型通常使用反向传播（backpropagation）和梯度下降等优化方法来训练网络，使得模型能够逐渐减少损失函数的值，找到最佳的权重参数。</li>
</ul>
<h4 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h4><ul>
<li><strong>深度结构</strong>：深度学习网络有多个隐藏层，通常包含上百或上千个神经元。</li>
<li><strong>自我特征提取</strong>：深度学习能够自动从原始数据中提取特征，而无需人工手动设计特征。这使得深度学习在处理复杂任务（如语音识别、自然语言处理、图像识别等）时表现优越。</li>
<li><strong>大数据和计算资源</strong>：深度学习通常需要大量的训练数据和强大的计算能力（如GPU）来训练深度神经网络。</li>
</ul>
<h3 id="3-深度学习和神经网络的关系"><a href="#3-深度学习和神经网络的关系" class="headerlink" title="3. 深度学习和神经网络的关系"></a>3. <strong>深度学习和神经网络的关系</strong></h3><ul>
<li><strong>深度学习是神经网络的一个子集</strong>：深度学习本质上是通过深层神经网络（DNN）来解决更复杂的任务。它是神经网络的一种扩展或进阶版本，强调使用深度（多层）的结构来提取数据中的高级特征。</li>
<li><strong>神经网络可以是浅层的</strong>：而深度学习网络通常都是深层的神经网络。浅层神经网络和深度学习之间的主要区别在于网络的深度（即隐藏层的数量）。</li>
<li><strong>深度学习模型的优势</strong>：深度学习能够从大量的复杂数据中学习到有用的表示（特征），并且在很多任务上超越了传统的浅层神经网络，尤其是在图像、语音、文本等领域。</li>
</ul>
<h3 id="4-神经网络的种类与深度学习的相关性"><a href="#4-神经网络的种类与深度学习的相关性" class="headerlink" title="4. 神经网络的种类与深度学习的相关性"></a>4. <strong>神经网络的种类与深度学习的相关性</strong></h3><p>深度学习使用的神经网络架构通常比传统的神经网络更加复杂和深层。常见的深度学习网络架构包括：</p>
<ul>
<li><strong>卷积神经网络（CNN）</strong>：专门用于处理图像数据，通过卷积层提取图像中的局部特征，广泛应用于图像分类、目标检测等任务。</li>
<li><strong>循环神经网络（RNN）</strong>：适用于处理序列数据，能够处理时间依赖性较强的问题，如语音识别、语言建模等。</li>
<li><strong>长短时记忆网络（LSTM）</strong>：RNN的一种变种，能够更好地捕捉长时间序列中的依赖关系。</li>
<li><strong>变换器网络（Transformer）</strong>：主要用于自然语言处理（NLP）任务，特别是语言模型（如BERT、GPT）。它基于自注意力机制，可以并行化训练并处理长序列数据。</li>
</ul>
<h3 id="5-深度学习的核心优势"><a href="#5-深度学习的核心优势" class="headerlink" title="5. 深度学习的核心优势"></a>5. <strong>深度学习的核心优势</strong></h3><ul>
<li><strong>自动特征学习</strong>：深度学习能够自动从原始数据中学习出特征，而不需要手动设计特征。这对于复杂的任务（如图像分类、语音识别等）非常有利。</li>
<li><strong>高维数据处理</strong>：深度神经网络能有效处理高维、复杂的数据，如图像、音频和文本等。</li>
<li><strong>性能提升</strong>：随着数据量和计算能力的增加，深度学习在许多任务上都表现出了比传统机器学习方法更优的性能。</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><ul>
<li><strong>神经网络</strong>是深度学习的基础，指的是由多个神经元连接组成的计算模型。传统神经网络通常是“浅层”的，只有少量的隐藏层。</li>
<li><strong>深度学习</strong>是利用深层神经网络（即具有多个隐藏层的神经网络）来自动学习数据的高级特征。深度学习通过多个层次的非线性映射，将复杂的输入数据转化为有用的表示，在许多任务中取得了突破性进展。</li>
</ul>
<p>简而言之，深度学习是基于神经网络的一种进阶应用，它通过深层次结构和大规模数据的处理，解决了更复杂、更抽象的问题。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/人工智能/">人工智能</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/深度学习/">深度学习</a><a href="/tags/硬件知识/">硬件知识</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/12/21/链表常见简单算法/"><span>链表常见简单算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/21/链表常见简单算法/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-21T12:24:56.000Z">
          2024-12-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkNode <span class="keyword">struct</span>&#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *LinkNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseLinkList</span><span class="params">(head *LinkNode)</span></span>*LinkNode&#123;</span><br><span class="line">    curr:=head</span><br><span class="line">    prev:=<span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> curr.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        next:=curr.Next</span><br><span class="line">        curr.Next=prev</span><br><span class="line">        prev=curr</span><br><span class="line">        curr=next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出链表倒数第K个节点值"><a href="#输出链表倒数第K个节点值" class="headerlink" title="输出链表倒数第K个节点值"></a>输出链表倒数第K个节点值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthFromEnd</span><span class="params">(head *LinkNode,k <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    curr:=head</span><br><span class="line">    count:=<span class="number">0</span></span><br><span class="line">    goal:=head</span><br><span class="line">    <span class="keyword">for</span> curr.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        curr=curr.Next</span><br><span class="line">        <span class="keyword">if</span> count&lt;k&#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            goal=goal.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> count&lt;k&#123;</span><br><span class="line">        retrun <span class="literal">nil</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> goal.Val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否有环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	slow, fast := head, head.Next</span><br><span class="line">	<span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">		<span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		slow = slow.Next</span><br><span class="line">		fast = fast.Next.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/数据结构与算法/">数据结构与算法</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/12/19/滑动窗口算法及应用场景/"><span>滑动窗口算法及应用场景</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/19/滑动窗口算法及应用场景/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-19T07:12:05.000Z">
          2024-12-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="滑动窗口基本思想"><a href="#滑动窗口基本思想" class="headerlink" title="滑动窗口基本思想"></a>滑动窗口基本思想</h2><p>滑动窗口主要应用在链表，数组等一维数据结构中，所谓窗口在算法中实际使用双指针来实现，主要要确定滑动指针的边界。</p>
<h2 id="滑动窗口算法实例"><a href="#滑动窗口算法实例" class="headerlink" title="滑动窗口算法实例"></a>滑动窗口算法实例</h2><ol>
<li>获取链表倒数第K个节点<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *LinkNode,k <span class="type">int</span>)</span></span>*LinkNode&#123;</span><br><span class="line">   slow:=head</span><br><span class="line">   fast:=head</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k&amp;&amp;fast!=<span class="literal">nil</span>;i++&#123;</span><br><span class="line">     fast = fast.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fast==<span class="literal">nil</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> fast!=<span class="literal">nil</span>&#123;</span><br><span class="line">      slow = slow.Next</span><br><span class="line">      fast.Next = fast.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> slow </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    maxLength := <span class="number">0</span></span><br><span class="line">    lastIndex := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">128</span>)</span><br><span class="line">    </span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast := <span class="number">0</span>; fast &lt; n; fast++ &#123;</span><br><span class="line">        currentChar := s[fast]</span><br><span class="line">        <span class="keyword">if</span> lastIndex[currentChar] &gt; start &#123;</span><br><span class="line">            start = lastIndex[currentChar]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> fast-start+<span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">            maxLength = fast - start + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastIndex[currentChar] = fast + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>leetcode [209] 长度最小的子数组<br>给定一个含有 n 个正整数的数组和一个正整数 slow 。<br>找出该数组中满足其总和大于等于 slow 的长度最小的 子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	minLen := <span class="built_in">len</span>(nums)+<span class="number">1</span> </span><br><span class="line">	left := <span class="number">0</span>                    <span class="comment">// 窗口的左边界</span></span><br><span class="line">	currentSum := <span class="number">0</span>              <span class="comment">// 当前窗口的和</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">		currentSum += nums[right] <span class="comment">// 将右边界的元素加入到当前窗口的和中</span></span><br><span class="line">		<span class="comment">// 当当前窗口的和大于等于 target 时，尝试缩小窗口</span></span><br><span class="line">		<span class="keyword">for</span> currentSum &gt;= target &#123;</span><br><span class="line">			minLen = min(minLen, right-left+<span class="number">1</span>) <span class="comment">// 更新最小长度</span></span><br><span class="line">			currentSum -= nums[left]           <span class="comment">// 从窗口的左边界减去元素</span></span><br><span class="line">			left++                             <span class="comment">// 移动左边界</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有找到符合条件的子数组，返回0</span></span><br><span class="line">	<span class="keyword">if</span> minLen == <span class="built_in">len</span>(nums)+<span class="number">1</span>  &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口应用场景"><a href="#滑动窗口应用场景" class="headerlink" title="滑动窗口应用场景"></a>滑动窗口应用场景</h2><p>滑动窗口算法是一种非常实用的算法技术，它在处理数组或字符串等序列数据时特别有用。以下是一些滑动窗口算法的应用场景：</p>
<ol>
<li><p><strong>寻找子数组&#x2F;子串的最小&#x2F;最大和</strong>：</p>
<ul>
<li>给定一个数组和一个整数k，找出所有长度为k的子数组的最大和或最小和。</li>
<li>给定一个数组和一个目标和，找出具有最大和的连续子数组。</li>
</ul>
</li>
<li><p><strong>寻找满足条件的子数组</strong>：</p>
<ul>
<li>如前所述，寻找满足总和大于等于某个特定值的最小长度子数组。</li>
<li>寻找数组中所有等于目标和的子数组。</li>
</ul>
</li>
<li><p><strong>字符串处理</strong>：</p>
<ul>
<li>找出字符串中不包含重复字符的最长子串。</li>
<li>找出字符串中满足特定条件的最短子串，例如包含所有特定字符的最短子串。</li>
</ul>
</li>
<li><p><strong>数据流问题</strong>：</p>
<ul>
<li>在处理数据流时，滑动窗口可以用来维护一个固定大小的数据窗口，以便于实时计算窗口内数据的统计信息。</li>
</ul>
</li>
<li><p><strong>时间序列分析</strong>：</p>
<ul>
<li>在金融领域，滑动窗口可以用来分析特定时间段内的股票价格变动。</li>
</ul>
</li>
<li><p><strong>滑动窗口协议</strong>：</p>
<ul>
<li>在计算机网络中，滑动窗口协议用于控制数据传输，确保接收方不会因为数据量过大而处理不过来。</li>
</ul>
</li>
<li><p><strong>图像处理</strong>：</p>
<ul>
<li>在图像处理中，滑动窗口可以用来识别图像中的特定模式或特征。</li>
</ul>
</li>
<li><p><strong>机器学习特征提取</strong>：</p>
<ul>
<li>在机器学习中，滑动窗口可以用来从时间序列数据中提取特征。</li>
</ul>
</li>
<li><p><strong>游戏开发</strong>：</p>
<ul>
<li>在游戏开发中，滑动窗口可以用来检测玩家在一定时间内的行为模式。</li>
</ul>
</li>
<li><p><strong>实时监控系统</strong>：</p>
<ul>
<li>在实时监控系统中，滑动窗口可以用来检测异常行为，例如在短时间内的频繁登录尝试。</li>
</ul>
</li>
</ol>
<p>滑动窗口算法因其简单和高效而在这些场景中被广泛使用。通过维护一个动态的窗口，算法可以在不遍历整个数据集的情况下，快速找到满足特定条件的数据子集。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/数据结构与算法/">数据结构与算法</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/12/18/记录一次context-cancel报错问题/"><span>记录一次context cancel报错问题</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/18/记录一次context-cancel报错问题/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-18T08:31:15.000Z">
          2024-12-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>生产环境数据库日志有大量报错内容为<code>context canceled</code>的记录。</p>
<h2 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h2><ol>
<li>根据报错日志，定位到报错<code>context canceled</code>发生在集中在ORM提交事务之前的DDL方法；<br>报错处业务场景:<br>服务为B&#x2F;S架构，数据同步页面后端服务使用golang-Goframe框架开发，数据库为PostgreSQL，服务业务逻辑为首次进入数据同步页面即执行<strong>数据同步</strong>（客户刷新页面并不会触发数据同步，只会显示历史数据），期间批量并发调用数据查询API并将返参更新到数据库中，因执行更新操作之前需要删除数据库原有数据，故整个删除更新操作开启了事务。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tx,err:=g.DB().Begin(ctx)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;&#125;</span><br><span class="line">tx.DB().Model(<span class="string">&quot;table&quot;</span>).Delete(<span class="string">&quot;key = ?&quot;</span>, key)</span><br><span class="line">_, err := tx.DB().Model(<span class="string">&quot;table&quot;</span>).Data(data).Batch(<span class="number">10</span>).Insert()</span><br></pre></td></tr></table></figure></li>
<li>回溯代码发现<code>Begin(ctx)</code>传入的<code>context</code>是请求handle使用的<code>context</code>,分别开始排查断开handle的原因<ol>
<li>通过接口测试工具排查接口耗时是否大于接口超时限制；</li>
<li>通过数据库最大连接数设置，观察活跃连接数排查服务是否存在连接池泄露问题；</li>
<li>假设是用户主动刷新页面导致连接被关闭；</li>
</ol>
</li>
<li>经测试，在接口返回之前模拟用户刷新操作可复现问题；</li>
<li>将<code>Begin(ctx)</code>的入参ctx改为通过<code>Background()</code>返回的根上下文，保证程序同步动作不因请求连接断开而结束；</li>
<li>为减少接口响应时间，还将事务拆分成多个小事务，也尝试使用乐观锁而不是用事务来执行<code>Update</code>操作；</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/工作笔记/">工作笔记</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/关系数据库/">关系数据库</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/12/18/限流的实现方式/"><span>限流的实现方式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/18/限流的实现方式/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-18T00:53:49.000Z">
          2024-12-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="限流目的"><a href="#限流目的" class="headerlink" title="限流目的"></a>限流目的</h2><p>限流是为保护自身系统和下游系统不被高并发流量冲垮，导致系统雪崩等问题。<br>在保证系统可用的情况下尽可能多增加进入的请求，其余的请求在排队等待，或者返回友好提示，保证里面进入系统的用户可以正常使用，防止系统雪崩。</p>
<h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p><img src="/../assets/tokenBucket.jpg" alt="令牌桶"><br>指定令牌桶的容量并以固定速率往令牌桶放置令牌，客户端请求时，首先查询令牌桶内的令牌数，若大于0则取出一个令牌，服务端正常处理客户端请求，否则服务端拒绝服务。<br>此外，如果令牌放置的速度比客户端请求的速度要快，令牌桶的令牌会一直增加直到令牌占满整个令牌桶。</p>
<h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h2><p><img src="/../assets/leakyBucket.jpg" alt="漏桶"><br>指定漏桶容量，同时漏桶会以一定速率放行客户端请求，当桶内请求数量累计数量大于桶容量时，请求被拒绝。</p>
<h2 id="令牌桶和漏桶的区别"><a href="#令牌桶和漏桶的区别" class="headerlink" title="令牌桶和漏桶的区别"></a>令牌桶和漏桶的区别</h2><p><strong>令牌桶</strong><br>    1. 令牌桶令牌数量是按照指定速率增加的；<br>    2. 令牌桶的容量是固定的，但放行（处理请求）的速度不是固定的，理论上支持的最大并发量就是桶内的容量；<br>    3. 系统的负载能力应该与令牌桶的容量以及放置令牌的速率相关；<br><strong>漏桶</strong><br>    1. 客户端请求以任意速率进入漏桶；<br>    2. 漏桶的容量是固定的，放行（处理请求）的速率也是固定的；<br>    3. 系统的负载能力应该与漏桶的放行速率相关；<br>总之，令牌桶在限制请求平均处理速率的基础上还允许突发的流量增加，而漏桶有更强的削峰能力，可以强制限制请求处理的速率，但漏桶出口的速度固定，因为计算性能固定，不能灵活的应对服务动态扩容的场景</p>
<h2 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h2><p>计数器算法是在一段时间间隔内（时间窗&#x2F;时间区间），处理请求的最大数量固定，超过部分不做处理。<br>例如：限制接口A在单位时间T内的访问次数不能超过X个。</p>
<ol>
<li>在每个单位时间T开始时，设置一个计数器counter，每有一个请求，counter就加1，如果counter的值小于X则放行请求，否则拒绝服务；</li>
<li>每个单位时间T结束时，重置counter。</li>
</ol>
<p><strong>计数器算法存在的临界问题</strong><br><img src="/../assets/counterBug_20241220121909.png" alt="临界问题"><br>如果在单位时间T的结束之前的一小段时间和下一个单位时间T开始之后的一小段时间内出现突发流量，理论上系统最大会承载2X个请求，此时流量速率是可能远大于限制的；</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/八股文/">八股文</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/分布式/">分布式</a><a href="/tags/网络/">网络</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/11/29/在浏览器输入域名并回车会发生哪些事情/"><span>在浏览器输入域名并回车会发生哪些事情</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/11/29/在浏览器输入域名并回车会发生哪些事情/" rel="bookmark">
        <time class="entry-date published" datetime="2024-11-29T13:42:55.000Z">
          2024-11-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="从TCP-x2F-IP网络模型角度理解"><a href="#从TCP-x2F-IP网络模型角度理解" class="headerlink" title="从TCP&#x2F;IP网络模型角度理解"></a>从TCP&#x2F;IP网络模型角度理解</h2><p>当你在浏览器中输入域名并按下回车键时，会触发一系列的网络活动，涉及到多个TCP&#x2F;IP网络模型中的协议和组件。以下是从浏览器输入域名到访问网页的大致流程，以及涉及的主要网络协议：</p>
<ol>
<li>DNS解析（域名系统协议 - DNS）：<br>•  当你在浏览器中输入一个域名时，首先需要将域名解析为IP地址。这通常通过DNS查询完成。<br>•  浏览器会检查本地的DNS缓存，如果没有找到对应的IP地址，它会向配置的DNS服务器发送查询请求。<br>•  DNS服务器会递归查询，直到找到对应的IP地址，并将结果返回给浏览器。</li>
<li>ARP协议（地址解析协议 - ARP）：<br>•  如果目标服务器与本地设备在同一局域网内，浏览器可能会使用ARP来将目标IP地址解析为MAC地址。</li>
<li>IP协议（网际协议 - IP）：<br>•  IP协议负责将数据封装成IP数据包，并在网络中传输。它会处理数据包从源到目的地的传输。</li>
<li>ICMP协议（互联网控制消息协议 - ICMP）：<br>•  如果在传输过程中遇到问题，如目的地不可达，ICMP协议可以用来发送错误消息。</li>
<li>TCP协议（传输控制协议 - TCP）：<br>•  一旦DNS解析出IP地址，浏览器会使用TCP协议建立到目标服务器的连接。这涉及到三次握手过程：<br>•  客户端发送SYN（同步序列编号）包到服务器。<br>•  服务器响应SYN-ACK（同步和确认）包。<br>•  客户端发送ACK（确认）包，完成握手。</li>
<li>HTTP&#x2F;HTTPS协议（超文本传输协议&#x2F;安全超文本传输协议）：<br>•  TCP连接建立后，浏览器会发送HTTP（或HTTPS，如果是加密连接）请求到服务器，请求获取网页内容。<br>•  如果是HTTPS连接，还会涉及到SSL&#x2F;TLS协议来建立安全连接，包括证书验证和加密通信。</li>
<li>FTP&#x2F;SFTP协议（文件传输协议&#x2F;安全文件传输协议）：<br>•  如果请求涉及下载文件，可能会使用FTP或SFTP协议。</li>
<li>SMTP&#x2F;POP3&#x2F;IMAP协议（简单邮件传输协议&#x2F;邮局协议&#x2F;互联网消息访问协议）：<br>•  如果请求涉及发送或接收电子邮件，可能会使用SMTP、POP3或IMAP协议。</li>
<li>TCP&#x2F;IP数据传输：<br>•  一旦HTTP请求被发送，服务器会处理请求并返回相应的HTML页面、图片、CSS文件、JavaScript文件等。<br>•  这些响应通过TCP连接传输回浏览器。</li>
<li>浏览器渲染：<br>•  浏览器接收到数据后，会解析HTML、CSS和JavaScript，并将网页渲染显示给用户。</li>
</ol>
<p>TCP&#x2F;IP网络模型通常被分为四层：应用层、传输层、网络层和数据链路层。以下是你提到的协议分别属于网络模型的哪一层：</p>
<ol>
<li>应用层：<br>•  DNS（域名系统协议）：负责将域名转换为IP地址。<br>•  HTTP&#x2F;HTTPS（超文本传输协议&#x2F;安全超文本传输协议）：用于客户端和服务器之间的请求和响应消息传输。<br>•  FTP&#x2F;SFTP（文件传输协议&#x2F;安全文件传输协议）：用于文件的传输。<br>•  SMTP&#x2F;POP3&#x2F;IMAP（简单邮件传输协议&#x2F;邮局协议&#x2F;互联网消息访问协议）：用于电子邮件的发送和接收。</li>
<li>传输层：<br>•  TCP（传输控制协议）：提供可靠的、面向连接的数据传输服务。<br>•  UDP（用户数据报协议）：提供不可靠的、无连接的数据传输服务（虽然UDP没有被提及，但它也是传输层的一个重要协议）。</li>
<li>网络层：<br>•  IP（网际协议）：负责数据包的寻址和路由。<br>•  ICMP（互联网控制消息协议）：用于发送错误消息和网络查询。</li>
<li>数据链路层：<br>•  ARP（地址解析协议）：将IP地址解析为MAC地址，用于同一局域网内的设备通信。<br>数据链路层还涉及到其他一些协议和机制，如以太网（Ethernet）用于局域网通信，以及各种网络接口卡（NIC）驱动程序等。</li>
</ol>
<h2 id="从云服务分布式部署架构理解"><a href="#从云服务分布式部署架构理解" class="headerlink" title="从云服务分布式部署架构理解"></a>从云服务分布式部署架构理解</h2><p>从浏览器输入域名并回车后的过程会涉及到多个网络协议和组件，具体如下：</p>
<ol>
<li>DNS解析：<br>•  首先，浏览器会进行DNS解析，将域名转换为IP地址。如果域名对应的服务是分布式部署的，DNS解析可能返回一个负载均衡器的IP地址，或者根据地理位置或其他策略返回不同区域服务器的IP地址。</li>
<li>负载均衡：<br>•  四层负载均衡：在IP+端口层面进行请求分发，根据IP地址和端口号将流量导向后端的具体服务器。<br>•  七层负载均衡：在应用层进行请求分发，可以根据URL、主机名等应用层信息将请求路由到不同的处理服务器。<br>•  负载均衡器可以根据不同的策略来分配请求，如轮询、最少连接、源IP散列或加权负载均衡。</li>
<li>网络协议：<br>•  HTTP&#x2F;HTTPS：用于浏览器与服务器之间的请求和响应消息传输。<br>•  TCP&#x2F;IP：负责数据包的寻址和路由。<br>•  UDP：在需要低延迟或高吞吐量的场景中使用，如实时应用、视频流或DNS查询。</li>
<li>服务发现与注册：<br>•  在分布式系统中，服务实例需要在服务注册中心注册自己，以便负载均衡器或其他服务能够发现并调用它们。常见的服务注册中心包括ETCD、Consul或Zookeeper。</li>
<li>服务网关：<br>•  服务网关负责路由、过滤和负载均衡，提供统一的服务入口。例如，Spring Cloud Gateway可以作为服务网关。</li>
<li>熔断器：<br>•  熔断器如Hystrix或Resilience4j，提供故障时的自动切断机制和降级服务，防止系统雪崩。</li>
<li>配置管理：<br>•  分布式配置中心如Spring Cloud Config或Apollo，用于统一管理配置信息，支持动态更新配置。</li>
<li>消息队列：<br>•  消息队列如RabbitMQ、Kafka等，用于异步通信和消息传递。</li>
<li>缓存和数据库：<br>•  分布式缓存如Redis、Memcached，以及分布式数据库如MySQL集群、Cassandra、HBase等，用于存储和查询数据。<br>通过这些组件和协议的协同工作，分布式系统能够处理大量的并发请求，提供高可用性和可扩展性。</li>
</ol>
<h2 id="从HTTP数据报文解析的角度理解"><a href="#从HTTP数据报文解析的角度理解" class="headerlink" title="从HTTP数据报文解析的角度理解"></a>从HTTP数据报文解析的角度理解</h2><ol>
<li>HTTP 请求<br>客户端发起HTTP请求，包含以下主要部分：<br>HTTP（HyperText Transfer Protocol） 是用于客户端和服务器之间传输超文本数据的协议，广泛用于万维网（Web）中。HTTP 是一种 应用层协议，它依赖于底层的 传输层协议（如 TCP 或 TLS&#x2F;SSL）来实现数据传输。</li>
</ol>
<p>HTTP 协议的基本结构</p>
<p>HTTP 协议是一个 请求-响应协议，它由 客户端（通常是浏览器）发起请求，服务器接收到请求后返回响应。它是无状态的协议，意味着每个请求都是独立的，服务器不维护客户端的状态。</p>
<ol>
<li>HTTP 请求</li>
</ol>
<p>HTTP 请求由客户端（如浏览器）发起，包含以下主要部分：</p>
<p>请求行（Request Line）</p>
<p>请求行由以下三部分组成：<br>    •	HTTP 方法：指定请求类型（如 GET、POST、PUT、DELETE 等）。<br>    •	请求 URL：指定服务器上的资源路径。<br>    •	HTTP 版本：指明客户端支持的 HTTP 协议版本，通常是 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</p>
<p>例如：</p>
<p>GET &#x2F;index.html HTTP&#x2F;1.1</p>
<p>请求头（Request Headers）</p>
<p>请求头包含客户端的一些信息，如浏览器类型、支持的语言、请求的主机、请求的时间等。常见的请求头包括：<br>    •	Host：指定请求的主机和端口号（例如：Host: <a target="_blank" rel="noopener" href="http://www.example.com)./">www.example.com）。</a><br>    •	User-Agent：客户端应用程序的详细信息（例如浏览器类型）。<br>    •	Accept：告诉服务器客户端支持哪些媒体类型（如 text&#x2F;html、application&#x2F;json）。<br>    •	Content-Type：请求体的类型（通常用于 POST 请求）。<br>    •	Authorization：用于传输认证信息（如用户名和密码）。</p>
<p>请求体（Request Body）</p>
<p>请求体主要用于包含客户端向服务器发送的数据，通常在 POST 或 PUT 请求中使用。GET 请求一般没有请求体。</p>
<ol start="2">
<li>HTTP 响应</li>
</ol>
<p>HTTP 响应由服务器发出，包含以下主要部分：</p>
<p>响应行（Response Line）</p>
<p>响应行由以下三部分组成：<br>    •	HTTP 版本：服务器使用的 HTTP 协议版本（例如 HTTP&#x2F;1.1）。<br>    •	状态码：表示请求处理的结果（如 200 OK、404 Not Found）。<br>    •	状态码描述：对状态码的描述（如 OK、Not Found）。</p>
<p>例如：</p>
<p>HTTP&#x2F;1.1 200 OK</p>
<p>响应头（Response Headers）</p>
<p>响应头包含服务器返回的一些元数据，如：<br>    •	Content-Type：返回的数据类型（如 text&#x2F;html、application&#x2F;json）。<br>    •	Content-Length：响应体的长度。<br>    •	Set-Cookie：服务器发送的 Cookie 数据，用于会话管理。<br>    •	Cache-Control：缓存控制指令（如 no-cache、max-age）。<br>    •	Date：响应生成的日期和时间。</p>
<p>响应体（Response Body）</p>
<p>响应体包含实际的数据内容，通常是客户端请求的资源（如 HTML 页面、图片、JSON 数据等）。</p>
<ol start="3">
<li>HTTP 方法</li>
</ol>
<p>HTTP 支持多种请求方法，常见的包括：<br>    •	GET：用于从服务器获取数据。是最常见的 HTTP 请求方法。请求中不会携带请求体。<br>    •	POST：用于向服务器发送数据。通常用于表单提交、文件上传等场景。<br>    •	PUT：用于更新服务器上的资源。<br>    •	DELETE：用于删除服务器上的资源。<br>    •	HEAD：类似于 GET，但服务器只返回响应头，不返回响应体。<br>    •	OPTIONS：用于获取服务器支持的 HTTP 方法。<br>    •	PATCH：用于部分更新资源。</p>
<ol start="4">
<li>HTTP 状态码<br>HTTP 状态码表示服务器对请求的响应状态。常见的 HTTP 状态码可以分为五个类别：</li>
</ol>
<p>1xx（信息性状态码）<br>    •	100 Continue：客户端可以继续发送请求的其余部分。<br>    •	101 Switching Protocols：服务器根据客户端的请求切换协议。</p>
<p>2xx（成功状态码）<br>    •	200 OK：请求成功，通常返回请求的资源。<br>    •	201 Created：请求成功并创建了新的资源。<br>    •	204 No Content：请求成功，但没有返回内容。</p>
<p>3xx（重定向状态码）<br>    •	301 Moved Permanently：请求的资源已永久移动到新位置。<br>    •	302 Found：请求的资源临时移动到新位置。<br>    •	304 Not Modified：资源未被修改，客户端可以使用缓存的副本。</p>
<p>4xx（客户端错误状态码）<br>    •	400 Bad Request：请求无效或缺少必需的参数。<br>    •	401 Unauthorized：请求要求身份验证。<br>    •	403 Forbidden：服务器理解请求但拒绝执行。<br>    •	404 Not Found：请求的资源不存在。</p>
<p>5xx（服务器错误状态码）<br>    •	500 Internal Server Error：服务器内部错误，导致无法完成请求。<br>    •	502 Bad Gateway：作为网关或代理的服务器收到了无效响应。<br>    •	503 Service Unavailable：服务器当前无法处理请求，通常是由于超载或维护。</p>
<ol start="5">
<li>HTTP 的连接管理</li>
</ol>
<p>长连接（Keep-Alive）</p>
<p>HTTP&#x2F;1.0 默认每个请求都建立一次新连接，服务器响应后立即关闭连接。为了优化性能，HTTP&#x2F;1.1 引入了 持久连接（即长连接），在同一 TCP 连接上处理多个请求，避免每次请求都建立新的连接，减少延迟。</p>
<p>管道化（Pipelining）</p>
<p>HTTP&#x2F;1.1 支持请求管道化（pipelining），即客户端可以在前一个请求尚未收到响应时，继续发送多个请求。这在减少延迟方面有一定优势，但并非所有服务器都支持。</p>
<ol start="6">
<li><p>HTTP&#x2F;2 和 HTTP&#x2F;3<br> •	HTTP&#x2F;2：相较于 HTTP&#x2F;1.1，HTTP&#x2F;2 引入了二进制帧、多路复用、头部压缩等新特性，使得请求和响应更高效，解决了 HTTP&#x2F;1.1 中存在的一些性能瓶颈。HTTP&#x2F;2 采用 二进制协议（而非文本协议）来提高传输效率。<br> •	HTTP&#x2F;3：基于 QUIC 协议的 HTTP&#x2F;3 进一步优化了性能，采用 UDP 作为传输层协议，提供更低的延迟和更快的连接建立速度。HTTP&#x2F;3 的核心优势是减少了握手时间，提高了数据传输的稳定性和效率。</p>
</li>
<li><p>安全性<br> •	HTTPS：HTTP Secure（HTTPS）是通过 TLS&#x2F;SSL 加密的 HTTP 协议，提供数据加密、身份验证和数据完整性，防止中间人攻击和窃听。通过加密的连接，HTTPS 可以确保用户和服务器之间的通信是安全的。</p>
</li>
</ol>
<p>总结</p>
<p>HTTP 协议是 Web 数据传输的基础，具有简单、灵活和易于实现的特点。虽然 HTTP&#x2F;1.1 已经被广泛使用，现代 Web 中很多应用已经开始采用更高效的 HTTP&#x2F;2 或 HTTP&#x2F;3 协议，以提高性能。通过对 HTTP 协议的理解，我们能够更好地设计和优化 Web 应用。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/计算机基础/">计算机基础</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/10/06/MySQL常见八股文/"><span>MySQL常见八股文</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/10/06/MySQL常见八股文/" rel="bookmark">
        <time class="entry-date published" datetime="2024-10-06T13:34:56.000Z">
          2024-10-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h2><p>一般来说，衡量事务必须满足四个特性：ACID，即 原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p>
<p>原子性（Atomicity）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p>一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
<p>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括<strong>读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</strong>。</p>
<p>持久性（Durability）：事务处理结束后，对数据的修改就是永久的，会持久化到硬盘上，即便系统故障也不会丢失。</p>
<h2 id="MySQL事务的隔离级别"><a href="#MySQL事务的隔离级别" class="headerlink" title="MySQL事务的隔离级别"></a>MySQL事务的隔离级别</h2><p>MySQL数据库支持四种事务隔离级别，这些级别定义了在并发环境下事务如何相互隔离，以避免不同类型的事务并发问题，如脏读、不可重复读和幻读。以下是四种事务隔离级别及其描述：</p>
<ol>
<li><p>READ UNCOMMITTED（读未提交）：<br>•  在这个级别下，事务可以读取到其他事务未提交的数据。这意味着可能会读到脏数据，因为其他事务可能最终会回滚。<br>•  脏读：可以读取到其他事务未提交的数据。<br>•  不可重复读：可能。<br>•  幻读：可能。</p>
</li>
<li><p>READ COMMITTED（读已提交）：<br>•  事务只能读取到其他事务已经提交的数据。这是大多数数据库系统的默认隔离级别。<br>•  脏读：不可能。<br>•  不可重复读：可能。<br>•  幻读：可能。</p>
</li>
<li><p>REPEATABLE READ（可重复读）：<br>•  事务在整个过程中可以多次读取到相同的数据集。这是MySQL的默认隔离级别（对于InnoDB存储引擎）。<br>•  脏读：不可能。<br>•  不可重复读：不可能。<br>•  幻读：可能（在MySQL中，REPEATABLE READ隔离级别实际上防止了幻读，因为它使用Next-Key Locks）。</p>
</li>
<li><p>SERIALIZABLE（串行化）：<br>•  这是最高的隔离级别，事务会完全隔离，事务会依次顺序执行，模拟了事务串行执行的场景。<br>•  脏读：不可能。<br>•  不可重复读：不可能。<br>•  幻读：不可能。</p>
</li>
</ol>
<p>在MySQL中，可以通过以下SQL语句查看和设置事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前会话的事务隔离级别：</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx_isolation</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看全局事务隔离级别：</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.tx_isolation;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置当前会话的事务隔离级别：</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL [隔离级别];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置全局事务隔离级别：</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL [隔离级别];</span><br></pre></td></tr></table></figure>
<p>其中[隔离级别]可以是READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ或SERIALIZABLE中的一个。需要注意的是，更改全局事务隔离级别可能需要具有相应的权限，并且在某些情况下，更改可能不会立即生效，因为MySQL可能需要重启才能应用新的全局设置。</p>
<h2 id="不可重复读和幻读对事务隔离性的影响"><a href="#不可重复读和幻读对事务隔离性的影响" class="headerlink" title="不可重复读和幻读对事务隔离性的影响"></a>不可重复读和幻读对事务隔离性的影响</h2><p>在数据库事务中，不可重复读（No-repeatable Read）和幻读（Phantom Read）是两种不同的并发问题，它们对事务的隔离性有不同的影响。<br>不可重复读（Non-repeatable read）是数据库事务中的一个并发问题，指的是在一个事务内，多次读取同一数据集合时，由于其他事务的干扰，读取到的结果不一致。<br>对事务隔离性的影响：<br>•  防止不可重复读：在可重复读隔离级别下，事务可以保证在整个事务期间对数据的读取是一致的，即使其他事务对数据进行了修改。<br>•  锁机制：为了实现可重复读，数据库通常会使用行级锁或间隙锁（Gap Locks）来防止其他事务修改或插入那些被当前事务读取的数据行。<br>幻读（Phantom Read）<br>幻读是指在一个事务内，第一次查询某条记录时不存在，但在后续的查询中却出现了，就像“幻影”一样。这通常是因为其他事务插入了新的记录，而这些记录符合当前事务的查询条件。<br>对事务隔离性的影响：<br>•  影响数据一致性：幻读可能会导致事务在逻辑上的数据不一致，尤其是在涉及范围查询和计数的场景中。<br>•  防止幻读的机制：为了防止幻读，数据库需要使用更复杂的锁机制，如Next-Key Locks（行锁和间隙锁的组合），这样可以锁定一个范围，防止其他事务在这个范围内插入新的记录。<br>对事务隔离性的影响总结<br>•  可重复读：提高了事务的隔离性，使得事务在执行期间能够看到一致的数据视图，但可能会因为锁的使用而降低并发性。<br>•  幻读：降低了事务的隔离性，因为它允许其他事务在当前事务执行期间插入新的记录，这可能会导致当前事务的逻辑错误。<br>在实际应用中，不同的数据库管理系统对于可重复读和幻读的处理方式可能有所不同。例如，MySQL的InnoDB存储引擎在可重复读隔离级别下通过Next-Key Locks机制来防止幻读，而其他数据库可能需要更高的隔离级别（如串行化）来防止幻读。选择合适的隔离级别需要在数据一致性和系统并发性之间做出权衡。</p>
<h2 id="MySQL的存储引擎有哪些"><a href="#MySQL的存储引擎有哪些" class="headerlink" title="MySQL的存储引擎有哪些"></a>MySQL的存储引擎有哪些</h2><p>MySQL支持多种存储引擎，每种存储引擎都有其独特的特点和适用场景。以下是一些常用的MySQL存储引擎及其使用场景：</p>
<ol>
<li>InnoDB存储引擎：<br>•  特点：支持事务处理、行级锁定和外键约束，适合需要高并发和数据一致性的应用。<br>•  适用场景：电子商务网站、金融系统等需要事务支持的场景。<br>•  优点：灾难恢复性好、支持事务、使用行级锁、支持外键关联、支持热备份。<br>•  缺点：占用的数据空间相对较大。</li>
<li>MyISAM存储引擎：<br>•  特点：插入和查询速度快，但不支持事务处理和外键约束，适合读密集型应用。<br>•  适用场景：内容管理系统、日志系统等读多写少的场景。<br>•  优点：读取速度快，不占用大量内存与存储资源。<br>•  缺点：更新机制浪费内存空间，需要依靠OPTIMIZE TABLE来恢复，主机宕机后，MyISAM表易损坏，灾难恢复性不佳。</li>
<li>Memory存储引擎：<br>•  特点：所有数据存储在内存中，读写速度快，但不支持事务处理和外键约束，数据在数据库重启后会丢失，适合临时数据存储。<br>•  适用场景：会话信息、临时表等需要快速访问的场景。<br>•  优点：提供内存表，显著提高访问数据的速度。<br>•  缺点：服务器重启后数据会丢失，复制维护时需要小心。</li>
<li>Archive存储引擎：<br>•  特点：提供高压缩存储，适用于存储历史数据或日志数据，只支持最基本的插入和查询功能。<br>•  适用场景：适用于存储历史数据或日志数据的归档。</li>
<li>CSV存储引擎：<br>•  特点：将数据存储在逗号分隔值的文本文件中，易于导入导出，不支持索引。<br>•  适用场景：数据导入导出，需要将数据存储在可读性强、易编辑的文件中的场景。</li>
<li>Federated存储引擎：<br>•  特点：允许MySQL服务器访问远程MySQL服务器上的表，类似于分布式数据库。<br>•  适用场景：分布式数据库系统，需要跨多个MySQL服务器访问数据的场景。<br>每种存储引擎都有其特定的优势和限制，选择时应根据具体的业务需求和场景来决定。</li>
</ol>
<h2 id="MySQL索引的存储结构为什么是B-树而不是B树"><a href="#MySQL索引的存储结构为什么是B-树而不是B树" class="headerlink" title="MySQL索引的存储结构为什么是B+树而不是B树"></a>MySQL索引的存储结构为什么是B+树而不是B树</h2><p>B树和B+树都是平衡多路查找树，用于索引和存储数据，但它们在数据结构和一些实现细节上有所不同。以下是B树和B+树的主要区别：</p>
<ol>
<li>节点结构：<br>•  B树：节点中既包含数据，也包含索引键。每个节点可以包含多个数据项和索引键，数据项和索引键是交替存储的。<br>•  B+树：节点中只包含索引键，不包含数据。数据存储在叶子节点，且叶子节点之间通过指针连接，形成一个链表。</li>
<li>数据存储位置：<br>•  B树：数据可以存储在树的任何节点中，包括非叶子节点。<br>•  B+树：数据只存储在叶子节点中，非叶子节点仅用于索引。</li>
<li>查询效率：<br>•  B树：查询可能在非叶子节点结束，因为数据可能存储在非叶子节点。<br>•  B+树：查询必须到达叶子节点，因为所有数据都存储在叶子节点。</li>
<li>树的高度：<br>•  B树：由于数据分布在所有节点中，树的高度相对较高。<br>•  B+树：由于非叶子节点不存储数据，只存储索引键，树的高度相对较低。</li>
<li>范围查询：<br>•  B树：进行范围查询时，需要在叶子节点中进行中序遍历。<br>•  B+树：进行范围查询时，可以直接在叶子节点的链表上进行，效率更高。</li>
<li>磁盘I&#x2F;O：<br>•  B树：由于树的高度较高，磁盘I&#x2F;O次数相对较多。<br>•  B+树：由于树的高度较低，磁盘I&#x2F;O次数相对较少。</li>
<li>空间利用率：<br>•  B树：节点中存储数据和索引键，空间利用率相对较低。<br>•  B+树：节点中只存储索引键，空间利用率相对较高，可以存储更多的索引键。</li>
<li>写操作：<br>•  B树：写操作时，可能需要对非叶子节点进行分裂，操作较为复杂。<br>•  B+树：写操作时，只需要对叶子节点进行分裂，操作相对简单。<br>MySQL选择B+树作为索引结构而不是B树，主要有以下几个原因：</li>
<li>查询性能更优：<br>•  B+树的所有数据都存储在叶子节点中，查询时只需要遍历一次叶子节点即可得到查询结果，而B树的数据既可能存储在非叶子节点中，也可能存储在叶子节点中。B树在查询时需要遍历非叶子节点和叶子节点，效率相对较低。</li>
<li>磁盘I&#x2F;O次数更少：<br>•  B+树的非叶子节点不存储数据，只存储索引键，因此可以存储更多的索引键，减少了树的高度，使得磁盘I&#x2F;O次数减少，查询更快。</li>
<li>更适于范围查询：<br>•  B+树的叶子节点通过指针相互连接，形成一个有序链表，方便顺序访问和范围查询。在B树中进行范围查询时，需要对B树进行中序遍历，而B+树的范围查询只需要对链表进行遍历即可。</li>
<li>查询效率更稳定：<br>•  B树的查询时间复杂度在1到树高之间，分别对应记录在根节点和叶节点，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。</li>
<li>空间利用率更高：<br>•  由于B+树的非叶子节点不存储数据，只存储索引键，因此在相同磁盘空间下，B+树可以存储更多的索引键，提高了空间利用率。</li>
<li>更适合外部存储：<br>•  B+树由于内节点无data域，每个节点能索引的范围更大更精确，使得B+树单次磁盘IO的信息量大于B树，从而减少了查询时需要的磁盘IO次数。<br>综上所述，B+树在查询性能、磁盘I&#x2F;O次数、范围查询以及查询效率稳定性方面相较于B树都有显著优势，这些特性使得B+树更适合作为MySQL数据库的索引结构。</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/八股文/">八股文</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/关系数据库/">关系数据库</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/06/18/常见的网络攻击方式/"><span>网络攻击方式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/06/18/常见的网络攻击方式/" rel="bookmark">
        <time class="entry-date published" datetime="2024-06-18T02:47:04.000Z">
          2024-06-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="常见的网络攻击方式"><a href="#常见的网络攻击方式" class="headerlink" title="常见的网络攻击方式"></a>常见的网络攻击方式</h2><ol>
<li>D-Dos攻击，分布式Dos攻击，即大批量请求目标服务器暴露出来的接口，使其无法正常响应其他用户的请求；</li>
<li>SQL注入；</li>
<li>DNS欺骗，攻击者伪造DNS响应，将用户重定向到恶意网站；</li>
<li>中间人攻击（篡改SSL证书，替换加密信息）；</li>
<li>会话劫持，窃取用户会话标识符，如cookie，接管用户的会话；</li>
<li>跨站脚本攻击（浏览器跨域校验）；</li>
<li>端口扫描（Port Scanning）：攻击者扫描网络以查找开放的端口，以确定潜在的入侵点；</li>
<li>缓冲区溢出攻击，输入的数据超出程序缓冲区的容量，导致程序崩溃或执行攻击者的代码；</li>
</ol>
<h2 id="如何预防D-Dos攻击"><a href="#如何预防D-Dos攻击" class="headerlink" title="如何预防D-Dos攻击"></a>如何预防D-Dos攻击</h2><ol>
<li>ip限制，设置ip白名单；</li>
<li>ip限流，限制每个ip单位时间内的请求次数；</li>
<li>加缓存中间件，如redis，消息队列中间件等，避免短时间内大量请求直接访问到数据库；</li>
<li>接口设计优化，接口涉及IO即访问数据库的尽量不用GET请求，入参校验cookie，或token这些；</li>
<li>使用高防高IP服务器；</li>
<li>分布式部署，保证可用性；</li>
<li>加一层CDN，让CDN抗住攻击；</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/网络/">网络</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/分布式/">分布式</a><a href="/tags/网络攻防/">网络攻防</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/03/25/理解golang的Context设计/"><span>理解golang的Context设计</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/03/25/理解golang的Context设计/" rel="bookmark">
        <time class="entry-date published" datetime="2024-03-25T03:22:57.000Z">
          2024-03-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Context的使用场景"><a href="#Context的使用场景" class="headerlink" title="Context的使用场景"></a>Context的使用场景</h2><p>Context的设计初衷就是为了在多个goroutine之间传递和同步取消信号，以减少资源的消耗和占用，具体有以下使用场景：</p>
<ol>
<li>作为请求API的调用方&amp;被调用方时的超时控制，通常用于数据库或者网络连接的超时控制；</li>
<li>作为各协程之间共用的变量池例如Gin框架中各中间件链式调用时互相传递Context；<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Deadline returns the time when work done on behalf of this context </span></span><br><span class="line">    <span class="comment">// should be canceled. </span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"><span class="comment">// Done returns a channel that&#x27;s closed when work done on behalf of this</span></span><br><span class="line">	<span class="comment">// context should be canceled.</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// If Done is not yet closed, Err returns nil.</span></span><br><span class="line">	<span class="comment">// If Done is closed, Err returns a non-nil error explaining why:</span></span><br><span class="line">	<span class="comment">// Canceled if the context was canceled</span></span><br><span class="line">	<span class="comment">// or DeadlineExceeded if the context&#x27;s deadline passed.</span></span><br><span class="line">	Err() <span class="type">error</span></span><br><span class="line"><span class="comment">// Value returns the value associated with this context for key, or nil</span></span><br><span class="line">	<span class="comment">// if no value is associated with key. Successive calls to Value with</span></span><br><span class="line">	<span class="comment">// the same key returns the same result.</span></span><br><span class="line">	Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Context超时控制的实现原理"><a href="#Context超时控制的实现原理" class="headerlink" title="Context超时控制的实现原理"></a>Context超时控制的实现原理</h2><p>通过<code>Done()</code>传递超时信号，并使用Select监听超时信号是否传入，官方注释如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done is provided for use in select statements:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  // Stream generates values with DoSomething and sends them to out</span></span><br><span class="line">	<span class="comment">//  // until DoSomething returns an error or ctx.Done is closed.</span></span><br><span class="line">	 <span class="function"><span class="keyword">func</span> <span class="title">Stream</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- Value)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	 	<span class="keyword">for</span> &#123;</span><br><span class="line">	 		v, err := DoSomething(ctx)</span><br><span class="line">	 		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	 			<span class="keyword">return</span> err</span><br><span class="line">	 		&#125;</span><br><span class="line">	 		<span class="keyword">select</span> &#123;</span><br><span class="line">	 		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">	 			<span class="keyword">return</span> ctx.Err()</span><br><span class="line">	 		<span class="keyword">case</span> out &lt;- v:</span><br><span class="line">	 		&#125;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Context的Keys池如何保证线程安全"><a href="#Context的Keys池如何保证线程安全" class="headerlink" title="Context的Keys池如何保证线程安全"></a>Context的Keys池如何保证线程安全</h2><p>官方<code>context</code>包下的Context接口内部对Keys没有使用传统锁的机制来保证线程安全，每次对<code>Context</code>的操作都会创建一个新的上下文实例，而不是改变现有的实例（通过<code>WithDeadline()</code>,<code>WithTimeOut()</code>和<code>WithCancle()</code>这些方法派生父节点上下文的副本），这样的设计避免了对共享资源的直接修改，从而避免了锁的需要。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Gin框架实现的<code>Context</code>内部是通过读写锁保证Key-Value变量池的线程安全</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set is used to store a new key/value pair exclusively for this context.</span></span><br><span class="line"><span class="comment">// It also lazy initializes  c.Keys if it was not used previously.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Set(key <span class="type">string</span>, value any) &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.Keys == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Keys = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]any)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.Keys[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the value for the given key, ie: (value, true).</span></span><br><span class="line"><span class="comment">// If the value does not exist it returns (nil, false)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Get(key <span class="type">string</span>) (value any, exists <span class="type">bool</span>) &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">	value, exists = c.Keys[key]</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/八股文/">八股文</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 谷涧月
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>