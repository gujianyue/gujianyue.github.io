<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | 谷涧月的学习流水账</title>

  
  <meta name="author" content="谷涧月">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="谷涧月的学习流水账"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="谷涧月的学习流水账" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">谷涧月的学习流水账</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2023/08/17/记录设计验权系统时的一些随想/"><span>记录设计验权系统时的一些随想</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/08/17/记录设计验权系统时的一些随想/" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-17T12:49:33.000Z">
          2023-08-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="OAuth2-0协议内容"><a href="#OAuth2-0协议内容" class="headerlink" title="OAuth2.0协议内容"></a>OAuth2.0协议内容</h2><p>OAuth 2.0 是一个行业标准的协议，用于授权。它允许第三方应用获取有限的访问权限，而无需将用户名和密码提供给第三方应用。OAuth 2.0 专注于客户端开发者的简易性，同时为Web应用、桌面应用、手机和起居室设备提供专门的认证流程。以下是 OAuth 2.0 协议的核心内容和组成部分：</p>
<ol>
<li>角色：<br>•  资源所有者（Resource Owner）：能够授权访问其资源的用户。<br>•  资源服务器（Resource Server）：存储受保护资源的服务器，只有经过授权的客户端才能访问。<br>•  客户端（Client）：请求访问受保护资源的应用程序。<br>•  授权服务器（Authorization Server）：负责颁发访问令牌给客户端。</li>
<li>流程：<br>•  授权码模式（Authorization Code Grant）：客户端引导资源所有者至授权服务器，用户登录并授权后，授权服务器返回一个授权码给客户端，客户端使用该码换取访问令牌。<br>•  密码模式（Resource Owner Password Credentials Grant）：客户端直接使用资源所有者的用户名和密码向授权服务器申请访问令牌。<br>•  客户端模式（Client Credentials Grant）：客户端直接向授权服务器申请访问令牌，适用于客户端代表自己访问资源的场景。<br>•  隐式模式（Implicit Grant）：适用于纯前端应用，客户端引导资源所有者至授权服务器，用户授权后，授权服务器直接返回访问令牌给客户端。<br>•  设备模式（Device Authorization Grant）：适用于无法通过常规流程进行用户交互的设备，例如物联网设备。</li>
<li>令牌：<br>•  访问令牌（Access Token）：允许客户端访问受保护资源的令牌。<br>•  刷新令牌（Refresh Token）：用于获取新的访问令牌，通常在访问令牌过期后使用。</li>
<li>安全性：<br>•  OAuth 2.0 要求使用HTTPS来保护所有OAuth流程中的通信，以防止令牌被截获。<br>•  访问令牌和刷新令牌应该是随机的、不可预测的，并且具有足够的长度。<br>•  客户端必须验证授权服务器的重定向URI。</li>
<li>扩展性：<br>•  OAuth 2.0 支持多种扩展，例如开放ID连接（OpenID Connect），它允许在OAuth 2.0授权过程中传递用户身份信息。<br>OAuth 2.0 协议是复杂的，并且需要根据具体的应用场景和安全要求来正确实施。它旨在提供一个安全、灵活且可扩展的授权框架，以满足不同应用的需求。</li>
</ol>
<h2 id="JWT和Cookie的使用场景差异"><a href="#JWT和Cookie的使用场景差异" class="headerlink" title="JWT和Cookie的使用场景差异"></a>JWT和Cookie的使用场景差异</h2><p>JWT（JSON Web Tokens）和Cookie是两种不同的技术，它们在Web应用中用于身份验证和信息传递，但它们之间存在一些关键的区别：</p>
<ol>
<li>存储位置：<br>•  Cookie：存储在客户端浏览器中，由浏览器自动处理。<br>•  JWT：可以存储在客户端（通常作为URL的一部分、存储在Cookie中或者LocalStorage&#x2F;SessionStorage中），也可以存储在服务端。</li>
<li>安全性：<br>•  Cookie：可以设置为仅通过HTTPS传输（Secure标志），并且可以设置HttpOnly标志，使得JavaScript无法访问，减少XSS攻击的风险。<br>•  JWT：本身是自包含的，包含所有必要的信息，因此不需要在服务器上存储会话信息。但是，JWT需要通过HTTPS传输以防止中间人攻击，且应使用强算法（如RS256）签名以防止篡改。</li>
<li>大小：<br>•  Cookie：大小受限（通常每个域名限制为20-30个Cookie，每个Cookie大小限制在4KB左右）。<br>•  JWT：理论上可以更大，但因为需要在HTTP请求头中传输，所以也不宜过大，以免影响性能。</li>
<li>性能：<br>•  Cookie：每次请求都会自动发送，可能会增加请求的大小，但不需要修改HTTP请求头。<br>•  JWT：需要在每次请求的HTTP头中明确指定，可能会增加请求头的大小，但不需要在服务器上查找会话信息。</li>
<li>会话管理：<br>•  Cookie：依赖于服务器端的会话存储，可以很容易地实现会话的注销和失效。<br>•  JWT：由于是自包含的，不需要服务器存储会话信息，但一旦发出，除非过期，否则不能轻易撤销。</li>
<li>跨域访问：<br>•  Cookie：受到同源策略的限制，不能跨域访问。<br>•  JWT：由于是作为请求的一部分发送，可以跨域使用。</li>
<li>用途：<br>•  Cookie：主要用于跟踪会话状态，也可以用于存储用户偏好等信息。<br>•  JWT：主要用于身份验证和信息交换，尤其是在分布式系统中。<br>总的来说，Cookie更适合用于会话管理，而JWT更适合用于分布式系统中的身份验证和信息交换。选择使用哪种技术取决于具体的应用场景和需求。</li>
</ol>
<h2 id="JWT-Json-Web-Tokens-包含哪些信息"><a href="#JWT-Json-Web-Tokens-包含哪些信息" class="headerlink" title="JWT(Json Web Tokens)包含哪些信息"></a>JWT(Json Web Tokens)包含哪些信息</h2><p>JWT（JSON Web Tokens）是一种紧凑且自包含的方式，用于在各方之间以JSON对象的形式安全地传输信息。JWT通常包含三个部分，用点.分隔，分别是Header（头部）、Payload（负载）和Signature（签名）。下面是每个部分通常包含的信息：</p>
<ol>
<li>Header（头部）：<br>•  typ：类型，通常为JWT。<br>•  alg：指定签名算法，如HS256（HMAC SHA-256）或RS256（RSA签名）。</li>
<li>Payload（负载）：<br>•  iss：发行人（Issuer），指的是token签发的主体。<br>•  exp：过期时间（Expiration Time），token的有效期。<br>•  iat：发行时间（Issued At），token签发的时间。<br>•  nbf：生效时间（Not Before），token在此时间前不可用。<br>•  sub：主题（Subject），通常指用户的唯一标识。<br>•  aud：受众（Audience），token的预期接收者。<br>•  jti：JWT ID，提供token的唯一标识，防止重复使用。<br>•  自定义声明：除了以上标准声明外，还可以包含其他业务相关的自定义声明。</li>
<li>Signature（签名）：<br>•  签名部分是由Header指定的算法、一个秘密（对于HS算法）或公钥&#x2F;私钥对（对于RS或ES算法）以及Header和Payload的编码后的字符串组成的。签名用于验证消息在传输过程中未被篡改，并且，对于使用私钥签名的token，还可以验证发送者的身份。<br>JWT的结构如下所示：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Header&gt;.&lt;Payload&gt;.&lt;Signature&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>•  Header和Payload通常使用Base64Url编码。<br>•  Signature是使用Header中指定的算法和密钥对Header和Payload的编码字符串进行签名的结果。<br>JWT的设计目的是在各方之间安全地传输信息，同时确保信息的完整性和可验证性。由于JWT可以包含敏感信息，因此在使用JWT时，必须通过HTTPS等安全协议传输，以防止中间人攻击。</p>
<h2 id="使用哈希加密算法加密保存敏感信息的一些注意事项"><a href="#使用哈希加密算法加密保存敏感信息的一些注意事项" class="headerlink" title="使用哈希加密算法加密保存敏感信息的一些注意事项"></a>使用哈希加密算法加密保存敏感信息的一些注意事项</h2><p>使用哈希加密算法加密保存敏感信息时，需要注意以下几个重要的事项：</p>
<ol>
<li>选择合适的哈希算法：<br>•  应使用当前认为安全的哈希算法，如SHA-256或SHA-512，避免使用已不安全的算法，如MD5和SHA-1。</li>
<li>盐值的使用：<br>•  为了防止彩虹表攻击，每个密码在哈希前应该加上一个唯一的盐值。盐值可以增加密码破解的难度。</li>
<li>哈希输出长度：<br>•  哈希输出应足够长（建议256位以上），以防止暴力破解和生日攻击。</li>
<li>安全存储哈希和盐值：<br>•  存储哈希值时，应将盐值与哈希值一起存储，但盐值本身不需要保密。</li>
<li>避免时序和功耗分析攻击：<br>•  使用恒定时间和随机化哈希算法，以防止通过分析算法执行来破解哈希值。</li>
<li>密码轮换和多因素身份验证：<br>•  在遭受攻击后，仅存储哈希值是不够的。应采用密码轮换和多因素身份验证。</li>
<li>数据传输安全：<br>•  敏感数据的传输应通过安全的通信通道（如HTTPS&#x2F;TLS）进行，以防止中间人攻击。</li>
<li>使用最新的安全标准：<br>•  加密与哈希算法不断发展，应定期更新应用程序，使用最新的安全标准和库。</li>
<li>密码存储格式：<br>•  一些哈希算法（如bcrypt）的哈希值包含了算法标识、成本因子和盐值，这些信息都嵌入在哈希值中，无需单独存储。</li>
<li>密码长度限制：<br>•  某些哈希算法（如bcrypt）对密码长度有限制，若密码超出此限制，需要进行额外处理。</li>
<li>不可逆性：<br>•  哈希算法的设计理念和加密原理确保了它在密码保护中的不可替代性。通过盐、成本因子以及不可逆的特性，可以有效抵御暴力破解和彩虹表攻击。</li>
<li>安全开发实践：<br>•  采用安全的开发实践对于保障敏感信息的安全至关重要，包括进行代码审查、定期的安全培训、漏洞扫描等。<br>遵循这些注意事项可以帮助提高敏感信息的安全性，保护用户数据免受恶意攻击。</li>
</ol>
<h2 id="MD5保存密码为什么不够安全了，SHA-256相比MD5有什么优势"><a href="#MD5保存密码为什么不够安全了，SHA-256相比MD5有什么优势" class="headerlink" title="MD5保存密码为什么不够安全了，SHA-256相比MD5有什么优势"></a>MD5保存密码为什么不够安全了，SHA-256相比MD5有什么优势</h2><p>MD5不如SHA-256安全的原因主要包括以下几点：</p>
<ol>
<li>哈希长度：<br>•  MD5产生128位的哈希值，而SHA-256产生256位的哈希值。更长的哈希值意味着更大的哈希空间，从而使得碰撞的概率更小，提高了安全性。</li>
<li>抗碰撞性：<br>•  MD5已被证明存在漏洞，容易受到碰撞攻击，即可以找到两个不同的输入值，它们产生相同的MD5哈希值。相比之下，SHA-256对碰撞攻击的抵抗力更强，目前还没有发现有效的攻击方法。</li>
<li>安全性：<br>•  MD5的安全性较弱，存在已知的漏洞，而SHA-256目前被认为更安全，没有发现严重的漏洞。</li>
<li>计算性能：<br>•  尽管MD5在计算速度上比SHA-256快，但安全性是更重要的考量因素。SHA-256虽然计算速度较慢，但由于其更长的哈希长度，提供了更高的安全性。</li>
<li>应用场景：<br>•  SHA-256由于其高安全性，被广泛应用于数字签名、区块链、文件校验等需要高安全性保障的场景。而MD5则更多用于一些对安全性要求不高的场景。</li>
<li>雪崩效应：<br>•  SHA-256具有高的雪崩效应，即输入的微小变化会导致输出的哈希值发生巨大变化，这增强了其安全性。</li>
<li>密码学弱点：<br>•  MD5的密码学弱点已经被广泛研究和利用，包括长度扩展攻击和碰撞攻击，而SHA-256在这方面的表现更为稳健。<br>综上所述，SHA-256在安全性、抗碰撞性、输出长度等方面都优于MD5，因此在需要高安全性的应用中，SHA-256是更安全的选择。</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/工作笔记/">工作笔记</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/JWT/">JWT</a><a href="/tags/OAuth2-0/">OAuth2.0</a><a href="/tags/哈希算法/">哈希算法</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/07/17/对GPM协程调度模型的个人理解/"><span>GPM协程调度模型的工作原理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/07/17/对GPM协程调度模型的个人理解/" rel="bookmark">
        <time class="entry-date published" datetime="2023-07-17T13:35:28.000Z">
          2023-07-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>理解GPM协程调度模型工作原理之前，先了解下<strong>协程、线程、进程之间的区别：</strong><br>    进程是操作系统进行资源分配的基本单位，线程是CPU调度的基本单位，其中协程相对于CPU调度的线程可以区分为用户态的线程和内核态的线程，实际运行时，CPU仍然只切换内核态的线程，协程可以通过协程调度器，让多个用户态的线程队列和一个CPU轮转期内核态的线程绑定运行也即在用户态实现并发，以达到减少线程切换时CPU资源浪费的目的。<br>协程的目的是在执行多线程任务时，减少CPU在切换线程上的调度消耗，以达到提高CPU的利用率。</p>
<p>GPM的G是goroutine协程，P是processor处理器是抽象的处理器，包含了协程运行的环境资源，M是Machine线程，内核状态的线程。goroutine相比于广义的协程，占用更小的内存空间，只占几KB的内存（线程占用约4MB，广义协程也是MB级别），调度更加灵活</p>
<p>G 表示 Goroutine，也就是 Go 语言中的轻量级线程。Goroutine 是一种并发执行的抽象，它比传统的线程更轻量、更高效，并且可以很容易地创建和销毁。</p>
<p>P 表示 Processor，也可以理解为上下文处理器。每个 P 其实就是一个相当于操作系统线程的抽象，负责执行 Goroutine。P 的个数可以通过 <code>GOMAXPROCS</code> 环境变量或者 <code>runtime.GOMAXPROCS</code> 函数进行设置。</p>
<p>M 表示 Machine，也就是操作系统线程和内核的直接映射，它负责管理真实的线程资源，并与操作系统进行交互。在 GPM 调度模型中，有多个 M，可以与多个 P 绑定。</p>
<p>N 表示工作队列的长度。工作队列用来存放待执行的 Goroutine，当某个 P 处于空闲状态时，会从工作队列中取出 Goroutine 执行。</p>
<p>GPM 调度模型的工作流程如下：</p>
<ol>
<li>当创建一个 Goroutine 时，它被放入当前 P 的本地队列（local run queue）中。</li>
<li>当本地队列为空时，P 会尝试从全局队列（global run queue）中偷取 Goroutine。</li>
<li>如果全局队列也为空，P 则会去其他空闲的 P 偷取 Goroutine。</li>
<li>当 P 获取到 Goroutine 后，将其放入自己的本地队列并执行。</li>
<li>P 执行完毕后，会检查是否需要进行垃圾回收操作。</li>
<li>若某个 P 长时间没有进展（例如发生了系统调用或者进入了休眠状态），它会释放与之关联的 M，并允许其他 Goroutine 使用。</li>
<li>被释放的 M 可以绑定到其他的 P，并开始执行新的 Goroutine。</li>
</ol>
<p>总结起来，GPM 调度模型通过将 Goroutine 分配给不同的 P 来实现并发执行，同时利用工作队列和偷取策略来平衡负载。这种调度模型在高并发、异步执行的场景下表现出色，使得开发者可以轻松地编写高效、高并发的程序。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/八股文/">八股文</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2023/07/01/尝试用python实现贪吃蛇/"><span>尝试用python实现贪吃蛇</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/07/01/尝试用python实现贪吃蛇/" rel="bookmark">
        <time class="entry-date published" datetime="2023-07-01T01:07:18.000Z">
          2023-07-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/../assets/pythonSnake%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: KEYDOWN.K_ENTER</span><br><span class="line">op0=&gt;operation: 食物刷新</span><br><span class="line">op1=&gt;operation: 控制行进方向</span><br><span class="line">cond1=&gt;condition: 吃到食物?</span><br><span class="line">cond2=&gt;condition: 触碰到边界或身体?</span><br><span class="line">e=&gt;end: Game Over</span><br><span class="line"></span><br><span class="line">st-&gt;op0-&gt;op1-&gt;cond1-&gt;cond2</span><br><span class="line">cond1(yes)-&gt;op0</span><br><span class="line">cond1(no)-&gt;cond2</span><br><span class="line">cond2(yes)-&gt;e</span><br><span class="line">cond2(no)-&gt;op1</span><br></pre></td></tr></table></figure>

<h3 id="场景元素图"><a href="#场景元素图" class="headerlink" title="场景元素图"></a>场景元素图</h3><p><img src="/../assets/%E5%9C%BA%E6%99%AF%E5%85%83%E7%B4%A0%E5%9B%BE-%E8%B4%AA%E5%90%83%E8%9B%87.png" alt="场景元素图-贪吃蛇"></p>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>方向调整</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>刷新食物位置</p>
<p>吃到食物</p>
<p>触碰到边界</p>
<h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><p>二维画布</p>
<p>一维蛇</p>
<p>点食物</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author：Wangdali time:2021年1月20日16:08:44</span></span><br><span class="line"><span class="comment">#python实现：贪吃蛇</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">游戏玩法：回车开始游戏；空格暂停游戏/继续游戏；方向键/wsad控制小蛇走向</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">思路：用列表存储蛇的身体；用浅色表示身体，深色背景将身体凸显出来；</span></span><br><span class="line"><span class="string">蛇的移动：仔细观察，是：身体除头和尾不动、尾部消失，头部增加，所以，新添加的元素放在列表头部、删除尾部元素；</span></span><br><span class="line"><span class="string">游戏结束判定策略：超出边界；触碰到自己的身体：蛇前进的下一格子为身体的一部分（即在列表中）。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#注：因为在列表中需要频繁添加和删除元素，所以用deque容器代替列表；是因为deque具有高效的插入和删除效率</span></span><br><span class="line"><span class="comment">#初始化蛇，长度为3，放置在屏幕左上角；</span></span><br><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.<span class="built_in">locals</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="comment">#基础设置</span></span><br><span class="line">Screen_Height=<span class="number">720</span></span><br><span class="line">Screen_Width=<span class="number">1280</span></span><br><span class="line">Size=<span class="number">20</span><span class="comment">#小方格大小</span></span><br><span class="line">Line_Width=<span class="number">1</span></span><br><span class="line"><span class="comment">#游戏区域的坐标范围</span></span><br><span class="line">Area_x=(<span class="number">0</span>,Screen_Width//Size-<span class="number">1</span>) <span class="comment">#0是左边界，1是右边界 #注：python中//为整数除法；/为浮点数除法</span></span><br><span class="line">Area_y=(<span class="number">2</span>,Screen_Height//Size-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#食物的初步设置</span></span><br><span class="line"><span class="comment">#食物的分值+颜色</span></span><br><span class="line">Food_Style_List=[(<span class="number">10</span>,(<span class="number">255</span>,<span class="number">100</span>,<span class="number">100</span>)),(<span class="number">20</span>,(<span class="number">100</span>,<span class="number">255</span>,<span class="number">100</span>)),(<span class="number">30</span>,(<span class="number">100</span>,<span class="number">100</span>,<span class="number">255</span>))]</span><br><span class="line"><span class="comment">#整体颜色设置</span></span><br><span class="line">Light=(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">Dark=(<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">Black=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">Red=(<span class="number">200</span>,<span class="number">30</span>,<span class="number">30</span>)</span><br><span class="line">Back_Ground=(<span class="number">40</span>,<span class="number">40</span>,<span class="number">60</span>)</span><br><span class="line"><span class="comment">#文本输出格式设置</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Print_Txt</span>(<span class="params">screen,font,x,y,text,fcolor=(<span class="params"><span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span></span>)</span>):</span><br><span class="line">    <span class="comment">#font.render参数意义：.render（内容，是否抗锯齿，字体颜色，字体背景颜色）</span></span><br><span class="line">    Text=font.render(text,<span class="literal">True</span>,fcolor)</span><br><span class="line">    screen.blit(Text,(x,y))</span><br><span class="line"><span class="comment">#初始化蛇</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_snake</span>():</span><br><span class="line">    snake=deque()</span><br><span class="line">    snake.append((<span class="number">2</span>,Area_y[<span class="number">0</span>]))</span><br><span class="line">    snake.append((<span class="number">1</span>,Area_y[<span class="number">0</span>]))</span><br><span class="line">    snake.append((<span class="number">0</span>,Area_y[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> snake</span><br><span class="line"><span class="comment">#食物设置</span></span><br><span class="line"><span class="comment">#注意需要对食物出现在蛇身上的情况进行判断</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Creat_Food</span>(<span class="params">snake</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    注：randint 产生的随机数区间是包含左右极限的，</span></span><br><span class="line"><span class="string">    也就是说左右都是闭区间的[1, n]，能取到1和n。</span></span><br><span class="line"><span class="string">    而 randrange 产生的随机数区间只包含左极限，</span></span><br><span class="line"><span class="string">    也就是左闭右开的[1, n)，1能取到，而n取不到。randint</span></span><br><span class="line"><span class="string">    产生的随机数是在指定的某个区间内的一个值，</span></span><br><span class="line"><span class="string">    而 randrange 产生的随机数可以设定一个步长，也就是一个间隔。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    food_x=random.randint(Area_x[<span class="number">0</span>],Area_x[<span class="number">1</span>]) <span class="comment">#此处有疑问</span></span><br><span class="line">    food_y=random.randint(Area_y[<span class="number">0</span>],Area_y[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#如果食物出现在蛇上，重来；</span></span><br><span class="line">    <span class="keyword">while</span>(food_x,food_y)<span class="keyword">in</span> snake:</span><br><span class="line">        food_x = random.randint(Area_x[<span class="number">0</span>], Area_x[<span class="number">1</span>])</span><br><span class="line">        food_y = random.randint(Area_y[[<span class="number">0</span>], Area_y[<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">return</span> food_x,food_y</span><br><span class="line"><span class="comment">#食物风格</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Food_Style</span>():</span><br><span class="line">    <span class="keyword">return</span> Food_Style_List[random.randint(<span class="number">0</span>,<span class="number">2</span>)] <span class="comment">#返回随机的分值和颜色</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    pygame.init()</span><br><span class="line">    screen=pygame.display.set_mode((Screen_Width,Screen_Height)) <span class="comment">#初始化一个准备显示的窗口或屏幕</span></span><br><span class="line">    pygame.display.set_caption(<span class="string">&#x27;贪吃蛇&#x27;</span>) <span class="comment">#Set the current window caption</span></span><br><span class="line">    <span class="comment">#得分字体设置</span></span><br><span class="line">    font1=pygame.font.SysFont(<span class="string">&#x27;SimHei&#x27;</span>,<span class="number">24</span>)</span><br><span class="line">    <span class="comment">#GO字体设置</span></span><br><span class="line">    font2 = pygame.font.SysFont(<span class="literal">None</span>, <span class="number">72</span>)</span><br><span class="line">    fwidth, fheight = font2.size(<span class="string">&#x27;GAME OVER&#x27;</span>) <span class="comment">###</span></span><br><span class="line">    <span class="comment">#程序bug修复：如果蛇在向右移动，快速点击分别施加向下、向左的命令，向下的命令会被覆盖，只有向左的命令被接受，直接GameOver</span></span><br><span class="line">    <span class="comment"># b变量为了防止这个情况发生</span></span><br><span class="line">    b=<span class="literal">True</span></span><br><span class="line">    <span class="comment">#蛇</span></span><br><span class="line">    snake=init_snake()</span><br><span class="line">    <span class="comment">#食物</span></span><br><span class="line">    food=Creat_Food(snake)</span><br><span class="line">    food_style=Food_Style()</span><br><span class="line">    <span class="comment">#方向控制</span></span><br><span class="line">    pos=(<span class="number">1</span>,<span class="number">0</span>) <span class="comment">###</span></span><br><span class="line">    <span class="comment">#启动游戏相关变量初始化</span></span><br><span class="line">    game_over=<span class="literal">True</span>  <span class="comment">#结束标志 # 是否开始，当start = True，game_over = True 时，才显示 GAME OVER</span></span><br><span class="line">    game_start=<span class="literal">False</span>    <span class="comment">#开始标志</span></span><br><span class="line">    score=<span class="number">0</span> <span class="comment">#得分</span></span><br><span class="line">    orispeed=<span class="number">0.3</span>  <span class="comment">#蛇初始速度</span></span><br><span class="line">    speed=orispeed  <span class="comment">#蛇速度</span></span><br><span class="line">    last_move_time=<span class="literal">None</span></span><br><span class="line">    pause=<span class="literal">False</span> <span class="comment">#暂停</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span>==QUIT:</span><br><span class="line">                sys.exit()</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span>==KEYDOWN:</span><br><span class="line">                <span class="keyword">if</span> event.key==K_RETURN:</span><br><span class="line">                    <span class="keyword">if</span> game_over:</span><br><span class="line">                        game_start=<span class="literal">True</span></span><br><span class="line">                        game_over=<span class="literal">False</span></span><br><span class="line">                        b=<span class="literal">True</span></span><br><span class="line">                        snake=init_snake()</span><br><span class="line">                        food=Creat_Food(snake)</span><br><span class="line">                        food_style=Food_Style()</span><br><span class="line">                        pos=(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                        <span class="comment">#得分</span></span><br><span class="line">                        score=<span class="number">0</span></span><br><span class="line">                        last_move_time=time.time()</span><br><span class="line">                <span class="keyword">elif</span> event.key==K_SPACE:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> game_over:</span><br><span class="line">                        pause=<span class="keyword">not</span> pause</span><br><span class="line">                <span class="comment">#以下为防止蛇在向右移动时按向左键，导致GameOver</span></span><br><span class="line">                <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_UP,K_w):</span><br><span class="line">                    <span class="keyword">if</span> b <span class="keyword">and</span> <span class="keyword">not</span> pos[<span class="number">1</span>]: <span class="comment">###</span></span><br><span class="line">                        pos=(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">                        b=<span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_DOWN,K_s):</span><br><span class="line">                    <span class="keyword">if</span> b <span class="keyword">and</span> <span class="keyword">not</span> pos[<span class="number">1</span>]:</span><br><span class="line">                        pos = (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                        b = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_LEFT,K_a):</span><br><span class="line">                    <span class="keyword">if</span> b <span class="keyword">and</span> <span class="keyword">not</span> pos[<span class="number">0</span>]:</span><br><span class="line">                        pos = (-<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                        b = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_RIGHT,K_d):</span><br><span class="line">                    <span class="keyword">if</span> b <span class="keyword">and</span> <span class="keyword">not</span> pos[<span class="number">0</span>]:</span><br><span class="line">                        pos = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                        b = <span class="literal">False</span></span><br><span class="line">        <span class="comment">#填充背景色</span></span><br><span class="line">        screen.fill(Back_Ground)</span><br><span class="line">        <span class="comment">###</span></span><br><span class="line">        <span class="comment">#画网格线、竖线</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(Size, Screen_Width, Size):</span><br><span class="line">            pygame.draw.line(screen, Black, (x, Area_y[<span class="number">0</span>] * Size), (x, Screen_Height), Line_Width)</span><br><span class="line">        <span class="comment">#画网格线、横线</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(Area_y[<span class="number">0</span>] * Size, Screen_Height, Size):</span><br><span class="line">            pygame.draw.line(screen, Black, (<span class="number">0</span>, y), (Screen_Width, y), Line_Width)</span><br><span class="line">        <span class="comment">#蛇的爬行过程</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> game_over:</span><br><span class="line">            curTime=time.time()</span><br><span class="line">            <span class="keyword">if</span> curTime-last_move_time&gt;speed: <span class="comment">###</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pause:</span><br><span class="line">                    b=<span class="literal">True</span></span><br><span class="line">                    last_move_time=curTime</span><br><span class="line">                    next_s = (snake[<span class="number">0</span>][<span class="number">0</span>] + pos[<span class="number">0</span>], snake[<span class="number">0</span>][<span class="number">1</span>] + pos[<span class="number">1</span>])</span><br><span class="line">                    <span class="comment">#如果吃到了食物</span></span><br><span class="line">                    <span class="keyword">if</span> next_s==food:</span><br><span class="line">                        snake.appendleft(next_s)</span><br><span class="line">                        score+=food_style[<span class="number">0</span>]</span><br><span class="line">                        speed = orispeed - <span class="number">0.03</span> * (score // <span class="number">100</span>)</span><br><span class="line">                        food = Creat_Food(snake)</span><br><span class="line">                        food_style = Food_Style()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment">#在区域内</span></span><br><span class="line">                        <span class="keyword">if</span> Area_x[<span class="number">0</span>]&lt;=next_s[<span class="number">0</span>]&lt;=Area_x[<span class="number">1</span>] <span class="keyword">and</span> Area_y[<span class="number">0</span>]&lt;=next_s[<span class="number">1</span>]&lt;=Area_y[<span class="number">1</span>] <span class="keyword">and</span> next_s <span class="keyword">not</span> <span class="keyword">in</span> snake:</span><br><span class="line">                            snake.appendleft(next_s)</span><br><span class="line">                            snake.pop()</span><br><span class="line">                        <span class="keyword">else</span> :</span><br><span class="line">                            game_over=<span class="literal">True</span></span><br><span class="line">        <span class="comment">#画食物</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> game_over:</span><br><span class="line">         <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        rect(Surface,color,Rect,width=0)</span></span><br><span class="line"><span class="string">第一个参数指定矩形绘制到哪个Surface对象上</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二个参数指定颜色</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第三个参数指定矩形的范围（left，top，width，height）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第四个参数指定矩形边框的大小（0表示填充矩形）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">例如绘制三个矩形：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pygame.draw.rect(screen, BLACK, (50, 50, 150, 50), 0)</span></span><br><span class="line"><span class="string">    pygame.draw.rect(screen, BLACK, (250, 50, 150, 50), 1)</span></span><br><span class="line"><span class="string">    pygame.draw.rect(screen, BLACK, (450, 50, 150, 50), 10)</span></span><br><span class="line"><span class="string">         &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 避免 GAME OVER 的时候把 GAME OVER 的字给遮住了</span></span><br><span class="line">        pygame.draw.rect(screen, food_style[<span class="number">1</span>], (food[<span class="number">0</span>] * Size, food[<span class="number">1</span>] * Size, Size, Size), <span class="number">0</span>)</span><br><span class="line">        <span class="comment">#画蛇</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> snake:</span><br><span class="line">            pygame.draw.rect(screen, Dark, (s[<span class="number">0</span>] * Size + Line_Width, s[<span class="number">1</span>] * Size + Line_Width,</span><br><span class="line">                                            Size - Line_Width * <span class="number">2</span>, Size - Line_Width * <span class="number">2</span>), <span class="number">0</span>)</span><br><span class="line">        Print_Txt(screen, font1, <span class="number">30</span>, <span class="number">7</span>, <span class="string">f&#x27;速度: <span class="subst">&#123;score // <span class="number">100</span>&#125;</span>&#x27;</span>)</span><br><span class="line">        Print_Txt(screen, font1, <span class="number">450</span>, <span class="number">7</span>, <span class="string">f&#x27;得分: <span class="subst">&#123;score&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="comment">#画GameOver</span></span><br><span class="line">        <span class="keyword">if</span> game_over:</span><br><span class="line">            <span class="keyword">if</span> game_start:</span><br><span class="line">                <span class="comment">#print(&#x27;GameOver&#x27;)</span></span><br><span class="line">                Print_Txt(screen, font2, (Screen_Width - fwidth) // <span class="number">2</span>, (Screen_Height - fheight) // <span class="number">2</span>, <span class="string">&#x27;GAME OVER&#x27;</span>,Red)</span><br><span class="line">        pygame.display.update()</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>




      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/自娱自乐/">自娱自乐</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/python/">python</a><a href="/tags/pygame/">pygame</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2022/08/05/golang初学笔记/"><span>golang初学笔记</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/08/05/golang初学笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2022-08-05T11:29:12.000Z">
          2022-08-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><p><a target="_blank" rel="noopener" href="https://go.dev/tour/list">A Tour of Go</a></p>
<p><a target="_blank" rel="noopener" href="https://gobyexample.com/">Go by Example</a></p>
<p><a target="_blank" rel="noopener" href="https://studygolang.gitbook.io/learn-go-with-tests">Learn Go with tests - learn-go-with-tests (gitbook.io)</a></p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/TCatTime/article/details/119272186"> Go基本数据类型_TCatTime的博客-CSDN博客_go 数据类型</a></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><a target="_blank" rel="noopener" href="https://www.qfgolang.com/?special=jichuyufa">Go语言基础语法-Golang基础语法-Golang中国 (qfgolang.com)</a></p>
<p>声明变量</p>
<table>
<thead>
<tr>
<th>声明方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>var 数据名称 type</td>
<td>数据值为默认值</td>
</tr>
<tr>
<td>数据名 :&#x3D;  值</td>
<td>:&#x3D;让编译器根据值自动判断数据类型）省去关键字var</td>
</tr>
</tbody></table>
<p>变量不可重复声明！</p>
<p>命名首字母是否大小写决定是否能够跨包调用，包内定义方法的方法名若是大写则表名可以被其他包调用，否则只能包内调用，类名，属性名同理；</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><ol>
<li><code>import _ &quot;包路径&quot;</code>因为go语言存在不使用即声明或直接导入则无法通过编译的规则，所以为了满足某些情况下仅需要调用某包的init函数的情景，可以进行匿名导入，即在包路径前添加”_ “ ；</li>
<li><code>import 别名 &quot;包路径&quot;</code>，起别名也是在包路径前添加”别名 “；</li>
<li><code>import . &quot;包路径&quot;</code>，将包内所有方法导入到本包中，这样调用导入包中方法时，可以直接通过方法名调用；</li>
</ol>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>在 Go 中枚举常量是使用 iota 枚举器创建的，在功能上，iota 关键字表示从 0 开始的整数常量；在作用上可以简化使用自动递增数字的常量定义，非常方便。</p>
<p>以前定义一个枚举值：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = 0</span><br><span class="line">    b = 1</span><br><span class="line">    c = 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Go 有了 iota 关键字后：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对应的值结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=0</span><br><span class="line">b=1</span><br><span class="line">c=2</span><br></pre></td></tr></table></figure>

<p>甚至还可以跳着来：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line"> a = iota</span><br><span class="line"> _</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对应的值结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=0</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br></pre></td></tr></table></figure>

<p>也可以玩出花来：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line"> bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1//x &lt;&lt; y表示x左移y位</span><br><span class="line"> bit1, mask1                           </span><br><span class="line"> _, _                                  </span><br><span class="line"> bit3, mask3                          </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对应的值结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bit0 == 1, mask0 == 0  (iota == 0)</span><br><span class="line">bit1 == 2, mask1 == 1  (iota == 1)</span><br><span class="line">                       (iota == 2, unused)</span><br><span class="line">bit3 == 8, mask3 == 7  (iota == 3)</span><br></pre></td></tr></table></figure>



<h3 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h3><ol>
<li><p>用于修饰方法，执行代码时会将defer修饰的方法输出结果依次压入栈中，在执行时完中括号内所有内容后再按出栈顺序输出结果；</p>
</li>
<li><p><code>defer</code> 和 <code>return</code>的执行顺序问题：</p>
<p>结论：同一方法内，被<code>defer</code>修饰的语句，其执行顺序在<code>return</code>动作之后；</p>
</li>
</ol>
<h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>[数组长度]type{值}</p>
<p>若值的个数小于数组长度，则剩余元素默认值为0，若大于则无法通过编译，且不同长度的数组无法互相传递；</p>
<h3 id="切片-动态数组"><a href="#切片-动态数组" class="headerlink" title="切片(动态数组)"></a>切片(动态数组)</h3><p>​	当数组声明时大括号内没有声明数组长度，则数组为动态数组；</p>
<h5 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h5><ol>
<li><p>声明方式一：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span> </span><br><span class="line">slice2 := []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>声明slice是一个动态数组，但是并没有给slice分配空间，要使用slice1需要先用make([]int, len)为其开辟空间 PS：用:&#x3D; 代替 &#x3D; 则可省略关键字var；</p>
</li>
<li><p>声明方式二：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>) </span><br></pre></td></tr></table></figure>

<p>其中len为数组的初始长度；</p>
</li>
<li><p>声明方式三：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myArray[] := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><ol>
<li><p>传递方式：切片的传递是引用传递，方法内对形参数组元素的修改会生效在实参上，且不同长度的动态数组都可以进行引用传递；</p>
</li>
<li><p><code>for range</code> 遍历：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> slice&#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>len()和cap()函数：len()可以获取切片当前长度，cap()可以获取切片当前容量，容量即切片实际开辟空间，长度则为读取切片的索引最大值，且cap也是动态扩容时的cap追加的数量（重要扩容机制）</p>
</li>
<li><p><code>append(slice, key)</code>：向切片末尾添加元素；</p>
</li>
<li><p>取切片元素 <code>s1 := slice[0:2]</code>，表明取切片的第1至第2个元素并赋值给<code>s1</code>，区间是左闭右开；</p>
</li>
<li><p><code>copy(copySlice2, slice1)</code>，将<code>slice1</code>的内容copy到<code>copySlice2</code>中，为值传递</p>
</li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h5 id="底层"><a href="#底层" class="headerlink" title="底层"></a><strong>底层</strong></h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/doreen211/article/details/125804019">GO中对map排序_雨雨不怕雨的博客-CSDN博客_go map 排序</a></p>
<p>GO语言中，map是哈希表，能够将特定类型的key映射到特定类型的Value上。在查询Map里面的内容时，其时间复杂度为O(1)非常高效。但其存储并不是线性的，遍历输出时，也没有顺序可言。</p>
<h5 id="声明方式-1"><a href="#声明方式-1" class="headerlink" title="声明方式"></a>声明方式</h5><ol>
<li><p>声明方式一：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap <span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure>

<p><code>map</code>和<code>slice</code>的特性一致，可以动态开辟空间，声明若采用此方式，则需要通过<code>make(myMap, len)</code>为其开辟空间进行初始化后才能使用；</p>
</li>
<li><p>声明方式二：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<p>其中<code>len</code>可以省略，省略编译器会默认给<code>myMap</code>分配一定空间；</p>
</li>
<li><p>声明方式三：</p>
</li>
</ol>
   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>: <span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key3&quot;</span>: <span class="string">&quot;value3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>: <span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key3&quot;</span>: <span class="string">&quot;value3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h5><ol>
<li><p>传递方式：同切片，为引用传递</p>
</li>
<li><p>添加：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myMap[<span class="string">&quot;key1&quot;</span>] = <span class="string">&quot;value1&quot;</span></span><br><span class="line">myMap[<span class="string">&quot;key2&quot;</span>] = <span class="string">&quot;value2&quot;</span></span><br><span class="line">myMap[<span class="string">&quot;key3&quot;</span>] = <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for range遍历</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> myMap&#123;&#125;</span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">printMap(myMap)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(myMay, <span class="string">&quot;key1&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMap[<span class="string">&quot;key1&quot;</span>] = <span class="string">&quot;value1_new&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示map查找</span></span><br><span class="line">	val , ok :=cities[<span class="string">&quot;no2&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> ok&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;找到了  值为%v&quot;</span>,val)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;没有找到&quot;</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="struct，封装"><a href="#struct，封装" class="headerlink" title="struct，封装"></a>struct，封装</h3><ol>
<li><p>给已定义数据类型起别名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="type">int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key <span class="type">int</span></span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">    Length <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getter和setter方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key <span class="type">int</span></span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">    Length <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *myStruct)</span></span> GetKey() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Key = &quot;</span> this.Key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *myStruct)</span></span> SetKey(newKey <span class="type">int</span>) &#123;</span><br><span class="line">    this.Key = newKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo := myStruct&#123;Key:<span class="number">11</span>, Value:<span class="string">&quot;test&quot;</span>, Length:<span class="number">10</span>&#125;<span class="comment">//属性名亦可省略不写</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *myStruct)</span></span> Sort()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is Sort of myStruct&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> superStruct <span class="keyword">struct</span>&#123;</span><br><span class="line">    myStruct <span class="comment">//superStruct继承了myStruct的方法</span></span><br><span class="line">    </span><br><span class="line">    Height <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承并重写父类myStruct的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *superStruct)</span></span> Sort()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is Sort of superStruct&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类对象 方式一</span></span><br><span class="line">demo1 := superStruct&#123;myStruct&#123;<span class="number">11</span>,<span class="string">&quot;test&quot;</span>,<span class="number">10</span>&#125;,<span class="number">120</span>&#125;</span><br><span class="line"><span class="comment">//创建子类对象 方式二</span></span><br><span class="line"><span class="keyword">var</span> demo2 superStruct</span><br><span class="line">demo2.Key = <span class="number">11</span></span><br><span class="line">demo2.Value = <span class="string">&quot;test&quot;</span></span><br><span class="line">demo2.Length = <span class="number">10</span></span><br><span class="line">demo2.Height = <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol>
<li><p><code>interface</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface的本质是一个指针，指向结构体及其内部的函数列表</span></span><br><span class="line"><span class="keyword">type</span> AnimalIf <span class="keyword">interface</span>&#123;</span><br><span class="line">    Sleep()</span><br><span class="line">    Eat()</span><br><span class="line">    GetColor() String<span class="comment">//获取动物颜色</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的类</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;</span><br><span class="line">	Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Cat)</span></span> Sleep()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Cat is sleeping&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Cat)</span></span> Eat()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Cat is eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Cat)</span></span> GetColor() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> this.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;</span><br><span class="line">	Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Dog)</span></span> Sleep()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Dog is sleeping&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Dog)</span></span> Eat()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Dog is eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Dog)</span></span> GetColor() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> this.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal AnimalIf</span><br><span class="line"><span class="comment">//因为interface本质是指针，所以传值给接口对象时需要用取地址符&amp;</span></span><br><span class="line">animal = &amp;Cat&#123;<span class="string">&quot;Black&quot;</span>&#125;</span><br><span class="line">animal.Sleep()</span><br><span class="line">animal = &amp;Dog&#123;<span class="string">&quot;White&quot;</span>&#125;</span><br><span class="line">animal.Sleep()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">animalSleep</span><span class="params">(animal AnimalIf)</span></span>&#123;</span><br><span class="line">    animal.Sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="万能类型"><a href="#万能类型" class="headerlink" title="万能类型"></a>万能类型</h3><p><code>interface&#123;&#125;</code> : 空接口</p>
<p>基本数据类型都实现了空接口</p>
<ol>
<li><p>作为形参时，可以接收所有类型的参数</p>
</li>
<li><p>给<code> interface&#123;&#125;</code>提供 “断言” 的机制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value, ok := demo.(<span class="type">string</span>)<span class="comment">//demo是interface类型,返回 value和ok</span></span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;demo is not a string type&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;demo is a string type, value= &quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>变量内置的<code>pair</code>结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span><span class="comment">// a: pair&lt;statictype:int, value:100&gt; </span></span><br><span class="line"><span class="keyword">var</span> demo myStruct = &#123;<span class="number">10</span>,<span class="string">&quot;test&quot;</span>,<span class="number">99.9</span>&#125;<span class="comment">//demo: pair&lt;type:myStruct, value&#123;10,&quot;test&quot;,99.9&#125;&gt;</span></span><br></pre></td></tr></table></figure>

<p>pair的结构用于断言判断类型</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p><code>defer</code>定义的语句会在程序结束时，即return或panic之前执行，这意味着，即便程序出现error并panic了，也依旧会执行defer语句。如果要判断是因为何种情况要结束程序才执行的<code>defer</code>，则需要通过recover()去捕获panic，若返回值不为nil则说明来自panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;panic occurred:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    err := findErr()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果定义了多个 <code>defer</code> 语句，它们会以逆序执行（Last In First Out，即后入先出）的顺序依次执行。这意味着最后一个定义的 <code>defer</code> 语句将是第一个执行的，并且最先定义的 <code>defer</code> 语句将是最后一个执行的。</p>
<h3 id="reflct"><a href="#reflct" class="headerlink" title="reflct"></a>reflct</h3><p>反射通过pair获取变量的类型和值。</p>
<p>方法：</p>
<ol>
<li><p><code>reflct.ValueOf()</code></p>
</li>
<li><p><code>reflct.TypeOf()</code></p>
</li>
</ol>
<p>使用场景：通过interface{}万能类型接收变量，再通过TypeOf()获得变量的动态类型，并通过ValueOf()获得参数运行时的值。</p>
<h3 id="Struct-Tag"><a href="#Struct-Tag" class="headerlink" title="Struct Tag"></a>Struct Tag</h3><p>通过<code>reflect.Type</code>获取结构体成员信息<code>reflect.StructField</code>结构中的 Tag 被称为结构体标签（Struct Tag）。结构体标签是对结构体字段的额外信息标签。使用场景有如定义结构体别名，使得在参数绑定时更好的一一对应</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书写格式</span></span><br><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`tag1:&quot;name&quot; tag2:&quot;名字&quot;`</span><span class="comment">//以键值对的方式书写并用反引号括起来</span></span><br><span class="line">    Sex <span class="type">string</span> <span class="string">`tag1:&quot;sex&quot; tag2:&quot;性别&quot;&#x27;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><a target="_blank" rel="noopener" href="https://www.liwenzhou.com/posts/Go/14_concurrence/">Go语言基础之并发 | 李文周的博客 (liwenzhou.com)</a></p>
<h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p><code>goroutine</code>是用户态的线程，由Go语言的运行时（runtime）调度完成。</p>
<h4 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h4><p>在调用函数的时候在前面加上 <code>go</code> 关键字，就可以为函数创建一个<code>goroutine</code>。</p>
<p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p>
<h5 id="特殊机制"><a href="#特殊机制" class="headerlink" title="特殊机制"></a>特殊机制</h5><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p>
<p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup<span class="comment">//sync.WaitGroup可以让main等待所有goroutine结束后再结束main()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">		<span class="keyword">go</span> hello(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="！！！需要注意的点！！！"><a href="#！！！需要注意的点！！！" class="headerlink" title="！！！需要注意的点！！！"></a><strong>！！！需要注意的点！！！</strong></h5><p> 若以闭包的方式运行goroutine时（如下所示）</p>
<blockquote>
<p>闭包函数:关于闭包，最简单的描述就是 ECMAScript 允许使用内部函数－－即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。</p>
<p>也就是说，内部函数会在外部函数返回后被执行。而当这个内部函数执行时，它仍然必需访问其外部函数的局部变量、参数以及其他内部函数。这些局部变量、参数和函数声明（最初时）的值是外部函数返回时的值，但也会受到内部函数的影响。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup<span class="comment">//sync.WaitGroup可以让main等待所有goroutine结束后再结束main()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">10000</span>) <span class="comment">// 计数牌+1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">        &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello main&quot;</span>)</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	闭包内含有一个作用域外部的变量，所以执行对应goroutine内容时需要再去访问该变量的值，此时该变量作为flag值已经在循环中并行执行了很多次，故绝大多数goroutine取到的变量值都是最后一次循环的变量值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方式：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup<span class="comment">//sync.WaitGroup可以让main等待所有goroutine结束后再结束main()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">10000</span>) <span class="comment">// 计数牌+1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">        &#125;(i) <span class="comment">// 解决方式：显式传递值给匿名函数，避免闭包</span></span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello main&quot;</span>)</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunsky303/p/9705727.html">深入Golang调度器之GMP模型 - sunsky303 - 博客园 (cnblogs.com)</a></p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p><code>channel</code>用于实现在多个<code>goroutine</code>间进行通信。</p>
<p>虽然<code>goroutine</code>可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure>

<p>举几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure>



<h5 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h5><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</strong></em></p>
<p>创建channel的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure>

<p>channel的缓冲大小是可选的。</p>
<p>举几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>



<h5 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h5><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>
<p>发送和接收都使用<code>&lt;-</code>符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p><strong>发送</strong></p>
<p>将一个值发送到通道中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure>

<p><strong>接收</strong></p>
<p>从一个通道中接收值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure>

<p><strong>关闭</strong></p>
<p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<ol>
<li>对一个关闭的通道再发送值就会导致panic。</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>关闭一个已经关闭的通道会导致panic。</li>
</ol>
<h4 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h4><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</span><br></pre></td></tr></table></figure>

<p>为什么会出现<code>deadlock</code>错误呢？</p>
<p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p>
<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p>
<p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	ret := &lt;-c</span><br><span class="line">	fmt.Println(<span class="string">&quot;接收成功&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>
<h4 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h4><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p>
<h5 id="从通道中取值的方式"><a href="#从通道中取值的方式" class="headerlink" title="从通道中取值的方式"></a>从通道中取值的方式</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启goroutine将0~100的数发送到ch中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="type">int</span>, ch2 <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//从通道中取值的方式1</span></span><br><span class="line">		i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		ch2 &lt;- i * i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">200</span>)</span><br><span class="line">	<span class="keyword">go</span> f1(ch1)</span><br><span class="line">	<span class="keyword">go</span> f2(ch1, ch2)</span><br><span class="line">	<span class="comment">//从通道中取值的方式2</span></span><br><span class="line">	<span class="keyword">for</span> ret := <span class="keyword">range</span> ch2 &#123;</span><br><span class="line">		fmt.Println(ret)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/学习笔记/">学习笔记</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/golang/">golang</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/01/05/Docker及个人云盘搭建学习笔记/"><span>Docker及个人云盘搭建学习笔记</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/01/05/Docker及个人云盘搭建学习笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2021-01-05T05:33:51.000Z">
          2021-01-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>前几天去朋友家，他给我演示了下云服务器的妙用，只见他轻轻敲出几行命令后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br><span class="line">//安装docker，我的云服务器系统是CentOS 7.5 64位</span><br><span class="line"></span><br><span class="line">docker pull nextcloud</span><br><span class="line">//拉取nextcloud镜像</span><br><span class="line"></span><br><span class="line">docker pull mysql:8.0</span><br><span class="line">//拉取mysql:8.0镜像</span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl enable docker</span><br><span class="line">//设置docker开机自启动</span><br><span class="line"></span><br><span class="line">docker run -d --name mysql     -v document_mysql:/var/lib/mysql     -e MYSQL_ROOT_PASSWORD=pw1     -e MYSQL_DATABASE=nextcloud     -e MYSQL_USER=user     -e MYSQL_PASSWORD=pw2     -p 3306:3306     mysql:8.0</span><br><span class="line">//在名为mysql的容器中启动mysql:8.0，并配置mysql环境变量：；-d 在后台运行容器，并且打印容器id,--name为容器指定一个名称；-volume,-v 绑定一个卷，格式为-v 本地目录:容器目录 或 -v 容器目录；-e 设置环境变量;</span><br><span class="line"></span><br><span class="line">docker run -d --name nextcloud     -v nextcloud:/var/www/html     --link mysql:mysql     -p 8080:80 nextcloud</span><br><span class="line">//在名为nextcloud的容器中启动nextcloud：--link 添加链接到另一个容器；-p 指定端口映射，格式为：主机(宿主)端口:容器端口</span><br></pre></td></tr></table></figure>



<p>我空空如也的服务器上就装上了可以多用户登陆的”个人网盘“！</p>
<p><img src="/../assets/5ed42e430e941d699918b0fc777360ed.png" alt="嘿嘿嘿"></p>
<p>回家后想起他神乎其神的操作，内心久久不能平静，所以自己查询资料做了点小笔记：</p>
<p>快速搭建私有云盘参考链接：<a target="_blank" rel="noopener" href="https://baiyue.one/archives/453.html">https://baiyue.one/archives/453.html</a></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>基于Go语言开发的开源项目</p>
<p><strong>术语：</strong></p>
<table>
<thead>
<tr>
<th align="center">概念</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Docker 镜像(Images)</td>
<td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td align="center">Docker 容器(Container)</td>
<td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td align="center">Docker 客户端(Client)</td>
<td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="center">Docker 主机(Host)</td>
<td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="center">Docker Registry</td>
<td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td>
</tr>
<tr>
<td align="center">Docker Machine</td>
<td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
<tr>
<td align="center">Volume(数据卷)</td>
<td align="left">通过数据卷可以在容器之间实现共享和重用；<br />对数据卷的修改会立马生效(非常适合作为开发环境)；<br />对数据卷的更新,不会影响镜像；<br />卷会一直存在,直到没有容器使用</td>
</tr>
</tbody></table>
<p><strong>和虚拟机的异同：</strong></p>
<p>相同点：</p>
<p>虚拟机和Docker同是使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/2480791?fr=aladdin">虚拟化技术</a>，来达到在同一平台上配备多个运行环境的目的；</p>
<p>不同点：</p>
<ol>
<li>虚拟机是通过软件模拟当前的硬件环境（硬件资源的虚拟化）来运行一个完整的操作系统，Docker自建的Docker容器（Container）是共用一个系统内核（内核级别的虚拟化）；</li>
</ol>
<p><img src="/../assets/8fffe9889eb532b0d541b3fc656db2ea.png" alt="VM vs Docker"></p>
<ol>
<li>虚拟机相对Docker非常笨重，因为承载了一个完整的操作系统导致占用硬件资源十分多，启动也很慢，而Docker中每个镜像文件大小十分轻便（MB级别大小），可以做到秒级启动</li>
</ol>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-architecture.html">https://www.runoob.com/docker/docker-architecture.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/学习笔记/">学习笔记</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/docker/">docker</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">上一页</a>
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 谷涧月
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>