<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务器性能指标过载排查思路</title>
      <link href="/2024/12/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E8%BF%87%E8%BD%BD%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"/>
      <url>/2024/12/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E8%BF%87%E8%BD%BD%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>当 Linux 服务器 的 CPU、内存 或 网络 出现过载时，通常意味着系统正在面临资源瓶颈或异常行为。为了排查这个问题，需要通过一系列的系统工具和方法来诊断和识别瓶颈的根本原因。以下是一些常见的排查步骤：</p><ol><li>检查 CPU 使用情况</li></ol><p>查看整体 CPU 使用情况：<br>    •使用 top 或 htop 命令查看当前系统的 CPU 使用率。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>htop 提供了更加友好的界面，可以使用它来动态地查看 CPU 负载。<br>    •%us：用户空间的 CPU 使用比例<br>    •%sy：内核空间的 CPU 使用比例<br>    •%id：空闲 CPU 时间<br>    •%wa：等待 I&#x2F;O 的 CPU 时间<br>    •%st：虚拟机偷取的 CPU 时间</p><p>查看每个进程的 CPU 使用情况：<br>    •使用 top 或 ps 命令查看当前占用 CPU 的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -o %CPU</span><br></pre></td></tr></table></figure><p>或者使用 ps 列出占用 CPU 的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --<span class="built_in">sort</span>=-%cpu | <span class="built_in">head</span> -n 10</span><br></pre></td></tr></table></figure><p>检查是否有进程陷入 无响应状态：<br>    •如果进程处于 D（uninterruptible sleep） 状态，表示它在等待 I&#x2F;O 操作完成，可能导致 CPU 被阻塞。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27; D &#x27;</span></span><br></pre></td></tr></table></figure><p>检查系统负载（load average）：<br>    •使用 uptime 或 top 命令查看系统负载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><p>负载均衡值（load average）显示的是在过去 1 分钟、5 分钟和 15 分钟内的平均进程数。高负载可能意味着系统 CPU 资源紧张。</p><ol start="2"><li>检查内存使用情况</li></ol><p>使用 free 命令查看内存使用：<br>    •free -m 可以查看系统内存的使用情况（单位是 MB）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure><pre><code>•Mem：总内存、已用内存、剩余内存。•Swap：交换分区的使用情况。高 swap 使用可能意味着物理内存不足，导致系统频繁交换数据到磁盘。</code></pre><p>检查进程的内存占用情况：<br>    •使用 top 或 ps 命令查看占用内存最多的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -o %MEM</span><br></pre></td></tr></table></figure><p>或者使用 ps 查看内存使用最多的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --<span class="built_in">sort</span>=-%mem | <span class="built_in">head</span> -n 10</span><br></pre></td></tr></table></figure><p>检查是否有 内存泄漏：<br>    •如果系统的可用内存持续下降，可以使用 smem（或者 pmap）查看各个进程的内存使用情况，排查是否有内存泄漏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smem -r</span><br></pre></td></tr></table></figure><p>使用 vmstat 查看虚拟内存情况：<br>    •vmstat 提供了系统的内存、交换区、I&#x2F;O、进程、CPU 等信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat 1</span><br></pre></td></tr></table></figure><pre><code>•si 和 so 分别表示交换内存的输入和输出。高交换活动通常意味着物理内存不足。</code></pre><p>检查内存是否有 OOM（Out of Memory） 错误：<br>    •如果系统没有足够的内存，它可能会启动 OOM Killer 来终止一些进程以释放内存。可以通过查看 &#x2F;var&#x2F;log&#x2F;messages 或 &#x2F;var&#x2F;log&#x2F;syslog 日志文件来确认是否发生了 OOM 错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/syslog | grep -i <span class="string">&quot;out of memory&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>检查网络使用情况</li></ol><p>使用 netstat 或 ss 查看网络连接：<br>    •netstat 或 ss 可以查看当前的网络连接及其状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tuln</span><br></pre></td></tr></table></figure><pre><code>•通过 -t 查看 TCP 连接，-u 查看 UDP 连接，-l 查看正在监听的端口，-n 显示数字格式。</code></pre><p>检查网络带宽使用情况：<br>    •使用 iftop 或 nload 监控网络流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iftop</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nload</span><br></pre></td></tr></table></figure><p>这些工具可以帮助你实时查看每个连接的流量情况，找出是否存在异常的流量高峰。</p><p>检查 TCP 状态：<br>    •使用 ss 查看 TCP 连接的状态，查找是否存在大量的 TIME_WAIT 或 CLOSE_WAIT 状态的连接，可能意味着有大量的关闭连接或连接未正常关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -s</span><br></pre></td></tr></table></figure><p>你可以检查 TIME_WAIT 和 CLOSE_WAIT 状态，如果这些连接积压过多，可能导致网络性能下降。</p><p>网络丢包或延迟：<br>    •使用 ping 测试到其他主机的连通性，检查是否有丢包现象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 10 &lt;destination_ip&gt;</span><br></pre></td></tr></table></figure><p>你可以查看是否存在高延迟或丢包，丢包可能指示网络硬件或带宽问题。</p><ol start="4"><li>检查磁盘 I&#x2F;O 使用情况</li></ol><p>使用 iostat 查看磁盘 I&#x2F;O 情况：<br>    •使用 iostat 检查磁盘的读取&#x2F;写入情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x 1</span><br></pre></td></tr></table></figure><pre><code>•%util：磁盘利用率，如果值接近 100%，表示磁盘繁忙。•await：磁盘操作的平均等待时间，较高的 await 值可能表示磁盘性能瓶颈。</code></pre><p>使用 dstat 或 iotop 监控磁盘 I&#x2F;O：<br>    •dstat 或 iotop 可以显示实时的磁盘 I&#x2F;O 使用情况，帮助你定位是否有某些进程正在占用大量磁盘 I&#x2F;O。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dstat -cdlmn</span><br></pre></td></tr></table></figure><p>或者使用 iotop：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iotop</span><br></pre></td></tr></table></figure><ol start="5"><li><p>分析日志文件<br> •查看 &#x2F;var&#x2F;log&#x2F;syslog、&#x2F;var&#x2F;log&#x2F;messages、&#x2F;var&#x2F;log&#x2F;dmesg 等系统日志，可能会有有关硬件故障、磁盘问题或其他异常行为的警告或错误信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/syslog | grep -i <span class="string">&quot;error&quot;</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/messages | grep -i <span class="string">&quot;error&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>其他工具<br> •sar（System Activity Reporter）：可以查看过去的系统性能数据，帮助你发现历史上的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sar -u 1 3  <span class="comment"># 查看 CPU 使用情况</span></span><br><span class="line">sar -r 1 3  <span class="comment"># 查看内存使用情况</span></span><br></pre></td></tr></table></figure><p> •dmesg：检查内核日志，查看是否有硬件故障或内存错误。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i error</span><br></pre></td></tr></table></figure><p>总结</p><p>当 Linux 服务器出现 CPU、内存或网络过载时，需要结合多种工具来诊断问题。通过 top&#x2F;htop 查看 CPU 和进程状态，使用 free&#x2F;iostat 监控内存和磁盘使用情况，利用 iftop&#x2F;ss 排查网络瓶颈，以及通过日志文件了解系统错误和警告。系统性能问题往往是多因素的，定位问题时需要逐步排查。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU工作原理</title>
      <link href="/2024/12/24/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8GPU%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E8%BF%90%E7%AE%97%E9%80%9F%E5%BA%A6/"/>
      <url>/2024/12/24/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8GPU%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E8%BF%90%E7%AE%97%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="GPU和CPU的区别"><a href="#GPU和CPU的区别" class="headerlink" title="GPU和CPU的区别"></a>GPU和CPU的区别</h2><p><strong>CPU架构设计</strong><br><img src="/../assets/cpu_arch.png" alt="CPU"><br><strong>CPU核心参数</strong><br><img src="/../assets/amd_cpu_bench.png" alt="CPU"><br><strong>GPU架构设计</strong><br><img src="/../assets/gpu_arch.png" alt="GPU"><br><strong>GPU核心参数</strong><br><img src="/../assets/gpu_bench.png" alt="GPU"><br>在CPU的架构中包含多级缓存，各种复杂操作指令集，CPU的架构设计是为了支持复杂的逻辑运算，每个核心都是完整通用的处理器单元，且其工作模式实际上是串行执行任务的，GPU的架构从设计之初就是专门用于处理图像和视频等图形数据,具有大量的流处理器和着色器，且其工作模式是并行执行任务的,从规格也可以看出除了核心数外同期的GPU比CPU有更高的时钟频率和内存带宽。<br>总结下来GPU和CPU的主要区别在以下几点：</p><ol><li>并行计算能力:<br>GPU：GPU设计为大规模的并行计算，具有数千个小型处理核心，这些核心能够同时执行大量的计算任务。深度学习中的许多计算（如矩阵乘法、卷积运算等）都可以高度并行化。GPU能够同时处理多个数据流（例如，多个神经元的计算），从而大大提高了训练效率。<br>CPU：CPU一般只有少数几个（通常为4到16个）强大的核心，适合处理顺序执行的任务。CPU适合执行需要复杂决策和高频任务的应用，但在深度学习中的大规模矩阵计算、卷积等任务上，其并行能力远逊色于GPU。</li><li>内存带宽:<br>GPU：GPU通常配备更宽的内存带宽，允许其快速访问和处理大规模的数据集。例如，现代GPU如NVIDIA的A100、V100、H100等，具有高达1TB&#x2F;s的内存带宽。这使得GPU在处理大规模数据集时能够更快地读取和写入数据，从而提高了训练速度。<br>CPU：虽然CPU的内存带宽也在不断提高，但通常远低于GPU。CPU的内存带宽有限，这使得它在处理深度学习中的大规模数据时，可能成为瓶颈，尤其是对于需要大量数据交换的神经网络模型（如大规模图像、视频处理等）。</li></ol><h2 id="适合GPU计算的场景"><a href="#适合GPU计算的场景" class="headerlink" title="适合GPU计算的场景"></a>适合GPU计算的场景</h2><ol><li>图形渲染和计算机视觉<br>图形渲染：GPU最初的设计目的是加速图形渲染，特别是3D图形。GPU在计算机图形学中通过执行大量并行的图形计算（如光照、阴影、纹理映射等）来加速渲染过程。<br>应用：视频游戏、虚拟现实（VR）、增强现实（AR）、3D建模和动画制作。<br>计算机视觉：GPU可以加速图像处理、目标检测、图像分割、面部识别、自动驾驶汽车中的视觉系统等任务。<br>应用：安防监控、医学影像分析、自动驾驶、工业视觉检测。</li><li>大规模矩阵计算<br>GPU：深度学习中的核心任务（如反向传播中的梯度计算和前向传播中的矩阵乘法）是矩阵计算密集型的。GPU特别适合这类任务，因为它能通过并行计算同时处理矩阵中的多个元素。NVIDIA的GPU通过CUDA等库进一步优化了这些运算，使得在训练深度学习模型时，GPU能够极大提升计算效率。<br>CPU：虽然CPU也能进行矩阵计算，但由于缺乏大规模的并行处理能力，CPU在执行大规模矩阵计算时远远不如GPU高效。</li><li>自然语言处理（NLP）<br>加速NLP任务：GPU在处理大规模文本数据、训练和推理自然语言处理模型（如Transformer、BERT、GPT等）时表现出色。NLP模型通常需要大量的计算资源来处理文本序列，GPU能够显著加速这些计算。<br>应用：机器翻译、语音识别、聊天机器人、情感分析、文本生成。</li><li>医学影像处理<br>CT、MRI图像处理：医学影像处理中常常需要进行大规模的数据分析和图像处理，GPU能够加速图像重建、分割、识别等任务。<br>自动诊断：Nvidia的GPU通过CUDA可以加速基于深度学习的自动化诊断系统，如利用卷积神经网络（CNN）进行肿瘤检测、器官分割等任务。</li></ol><h2 id="深度学习和神经网络"><a href="#深度学习和神经网络" class="headerlink" title="深度学习和神经网络"></a>深度学习和神经网络</h2><p><strong>深度学习</strong>和<strong>神经网络</strong>是紧密相关的概念，但它们并不完全相同。以下是它们之间的关系及区别：</p><h3 id="1-神经网络（Neural-Networks）"><a href="#1-神经网络（Neural-Networks）" class="headerlink" title="1. 神经网络（Neural Networks）"></a>1. <strong>神经网络（Neural Networks）</strong></h3><p>神经网络是模仿生物神经系统的计算模型，尤其是大脑神经元之间的连接结构。在人工智能领域，神经网络被用来进行数据处理和模式识别。</p><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><ul><li><strong>神经网络（Neural Network）</strong>：由一组互相连接的节点（即神经元）组成，这些神经元通过权重相连。神经网络可以进行监督学习和非监督学习，用于完成分类、回归等任务。</li><li><strong>层次结构</strong>：神经网络通常包含输入层、隐藏层和输出层。每一层包含若干神经元（节点），每个神经元接受前一层的输出，并通过激活函数处理后传递给下一层。</li><li><strong>激活函数</strong>：通常使用如ReLU、Sigmoid、Tanh等激活函数来增加网络的非线性能力。</li></ul><h4 id="传统神经网络（浅层神经网络）："><a href="#传统神经网络（浅层神经网络）：" class="headerlink" title="传统神经网络（浅层神经网络）："></a>传统神经网络（浅层神经网络）：</h4><ul><li>神经网络最初并不深，通常只有一层或两层隐藏层（即浅层神经网络）。这些浅层网络对于一些简单的任务（如线性可分问题）效果良好。</li><li><strong>不足</strong>：浅层神经网络无法有效地处理复杂、高维的数据和任务（如图像识别、自然语言处理等），并且存在梯度消失和梯度爆炸的问题。</li></ul><h3 id="2-深度学习"><a href="#2-深度学习" class="headerlink" title="2. 深度学习"></a>2. <strong>深度学习</strong></h3><p>深度学习是神经网络的一种拓展，它指的是具有多个隐藏层（即深层结构）的神经网络模型。深度学习的“深度”通常指的是网络中有多个隐藏层，而这些层次使得模型能够自动学习和提取数据的高级特征。</p><h4 id="基本概念：-1"><a href="#基本概念：-1" class="headerlink" title="基本概念："></a>基本概念：</h4><ul><li><strong>深度神经网络</strong>：深度学习中的神经网络通常包含很多隐藏层，这些层使得模型能够逐步提取数据的高层次特征。</li><li><strong>多层学习</strong>：每一层可以从前一层的输出中学习到更复杂的特征。比如，在图像识别中，浅层可以学习边缘和简单形状，中间层可以学习纹理和局部结构，深层可以学习复杂的对象或场景。</li><li><strong>反向传播算法</strong>：深度学习模型通常使用反向传播（backpropagation）和梯度下降等优化方法来训练网络，使得模型能够逐渐减少损失函数的值，找到最佳的权重参数。</li></ul><h4 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h4><ul><li><strong>深度结构</strong>：深度学习网络有多个隐藏层，通常包含上百或上千个神经元。</li><li><strong>自我特征提取</strong>：深度学习能够自动从原始数据中提取特征，而无需人工手动设计特征。这使得深度学习在处理复杂任务（如语音识别、自然语言处理、图像识别等）时表现优越。</li><li><strong>大数据和计算资源</strong>：深度学习通常需要大量的训练数据和强大的计算能力（如GPU）来训练深度神经网络。</li></ul><h3 id="3-深度学习和神经网络的关系"><a href="#3-深度学习和神经网络的关系" class="headerlink" title="3. 深度学习和神经网络的关系"></a>3. <strong>深度学习和神经网络的关系</strong></h3><ul><li><strong>深度学习是神经网络的一个子集</strong>：深度学习本质上是通过深层神经网络（DNN）来解决更复杂的任务。它是神经网络的一种扩展或进阶版本，强调使用深度（多层）的结构来提取数据中的高级特征。</li><li><strong>神经网络可以是浅层的</strong>：而深度学习网络通常都是深层的神经网络。浅层神经网络和深度学习之间的主要区别在于网络的深度（即隐藏层的数量）。</li><li><strong>深度学习模型的优势</strong>：深度学习能够从大量的复杂数据中学习到有用的表示（特征），并且在很多任务上超越了传统的浅层神经网络，尤其是在图像、语音、文本等领域。</li></ul><h3 id="4-神经网络的种类与深度学习的相关性"><a href="#4-神经网络的种类与深度学习的相关性" class="headerlink" title="4. 神经网络的种类与深度学习的相关性"></a>4. <strong>神经网络的种类与深度学习的相关性</strong></h3><p>深度学习使用的神经网络架构通常比传统的神经网络更加复杂和深层。常见的深度学习网络架构包括：</p><ul><li><strong>卷积神经网络（CNN）</strong>：专门用于处理图像数据，通过卷积层提取图像中的局部特征，广泛应用于图像分类、目标检测等任务。</li><li><strong>循环神经网络（RNN）</strong>：适用于处理序列数据，能够处理时间依赖性较强的问题，如语音识别、语言建模等。</li><li><strong>长短时记忆网络（LSTM）</strong>：RNN的一种变种，能够更好地捕捉长时间序列中的依赖关系。</li><li><strong>变换器网络（Transformer）</strong>：主要用于自然语言处理（NLP）任务，特别是语言模型（如BERT、GPT）。它基于自注意力机制，可以并行化训练并处理长序列数据。</li></ul><h3 id="5-深度学习的核心优势"><a href="#5-深度学习的核心优势" class="headerlink" title="5. 深度学习的核心优势"></a>5. <strong>深度学习的核心优势</strong></h3><ul><li><strong>自动特征学习</strong>：深度学习能够自动从原始数据中学习出特征，而不需要手动设计特征。这对于复杂的任务（如图像分类、语音识别等）非常有利。</li><li><strong>高维数据处理</strong>：深度神经网络能有效处理高维、复杂的数据，如图像、音频和文本等。</li><li><strong>性能提升</strong>：随着数据量和计算能力的增加，深度学习在许多任务上都表现出了比传统机器学习方法更优的性能。</li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><ul><li><strong>神经网络</strong>是深度学习的基础，指的是由多个神经元连接组成的计算模型。传统神经网络通常是“浅层”的，只有少量的隐藏层。</li><li><strong>深度学习</strong>是利用深层神经网络（即具有多个隐藏层的神经网络）来自动学习数据的高级特征。深度学习通过多个层次的非线性映射，将复杂的输入数据转化为有用的表示，在许多任务中取得了突破性进展。</li></ul><p>简而言之，深度学习是基于神经网络的一种进阶应用，它通过深层次结构和大规模数据的处理，解决了更复杂、更抽象的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 硬件知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表常见简单算法</title>
      <link href="/2024/12/21/%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"/>
      <url>/2024/12/21/%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkNode <span class="keyword">struct</span>&#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *LinkNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseLinkList</span><span class="params">(head *LinkNode)</span></span>*LinkNode&#123;</span><br><span class="line">    curr:=head</span><br><span class="line">    prev:=<span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> curr.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        next:=curr.Next</span><br><span class="line">        curr.Next=prev</span><br><span class="line">        prev=curr</span><br><span class="line">        curr=next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出链表倒数第K个节点值"><a href="#输出链表倒数第K个节点值" class="headerlink" title="输出链表倒数第K个节点值"></a>输出链表倒数第K个节点值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthFromEnd</span><span class="params">(head *LinkNode,k <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    curr:=head</span><br><span class="line">    count:=<span class="number">0</span></span><br><span class="line">    goal:=head</span><br><span class="line">    <span class="keyword">for</span> curr.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        curr=curr.Next</span><br><span class="line">        <span class="keyword">if</span> count&lt;k&#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            goal=goal.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> count&lt;k&#123;</span><br><span class="line">        retrun <span class="literal">nil</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> goal.Val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否有环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slow, fast := head, head.Next</span><br><span class="line"><span class="keyword">for</span> slow != fast &#123;</span><br><span class="line"><span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口算法及应用场景</title>
      <link href="/2024/12/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2024/12/19/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口基本思想"><a href="#滑动窗口基本思想" class="headerlink" title="滑动窗口基本思想"></a>滑动窗口基本思想</h2><p>滑动窗口主要应用在链表，数组等一维数据结构中，所谓窗口在算法中实际使用双指针来实现，主要要确定滑动指针的边界。</p><h2 id="滑动窗口算法实例"><a href="#滑动窗口算法实例" class="headerlink" title="滑动窗口算法实例"></a>滑动窗口算法实例</h2><ol><li>获取链表倒数第K个节点<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *LinkNode,k <span class="type">int</span>)</span></span>*LinkNode&#123;</span><br><span class="line">   slow:=head</span><br><span class="line">   fast:=head</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k&amp;&amp;fast!=<span class="literal">nil</span>;i++&#123;</span><br><span class="line">     fast = fast.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> fast==<span class="literal">nil</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> fast!=<span class="literal">nil</span>&#123;</span><br><span class="line">      slow = slow.Next</span><br><span class="line">      fast.Next = fast.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> slow </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    maxLength := <span class="number">0</span></span><br><span class="line">    lastIndex := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">128</span>)</span><br><span class="line">    </span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast := <span class="number">0</span>; fast &lt; n; fast++ &#123;</span><br><span class="line">        currentChar := s[fast]</span><br><span class="line">        <span class="keyword">if</span> lastIndex[currentChar] &gt; start &#123;</span><br><span class="line">            start = lastIndex[currentChar]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> fast-start+<span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">            maxLength = fast - start + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastIndex[currentChar] = fast + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>leetcode [209] 长度最小的子数组<br>给定一个含有 n 个正整数的数组和一个正整数 slow 。<br>找出该数组中满足其总和大于等于 slow 的长度最小的 子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">minLen := <span class="built_in">len</span>(nums)+<span class="number">1</span> </span><br><span class="line">left := <span class="number">0</span>                    <span class="comment">// 窗口的左边界</span></span><br><span class="line">currentSum := <span class="number">0</span>              <span class="comment">// 当前窗口的和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">currentSum += nums[right] <span class="comment">// 将右边界的元素加入到当前窗口的和中</span></span><br><span class="line"><span class="comment">// 当当前窗口的和大于等于 target 时，尝试缩小窗口</span></span><br><span class="line"><span class="keyword">for</span> currentSum &gt;= target &#123;</span><br><span class="line">minLen = min(minLen, right-left+<span class="number">1</span>) <span class="comment">// 更新最小长度</span></span><br><span class="line">currentSum -= nums[left]           <span class="comment">// 从窗口的左边界减去元素</span></span><br><span class="line">left++                             <span class="comment">// 移动左边界</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有找到符合条件的子数组，返回0</span></span><br><span class="line"><span class="keyword">if</span> minLen == <span class="built_in">len</span>(nums)+<span class="number">1</span>  &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口应用场景"><a href="#滑动窗口应用场景" class="headerlink" title="滑动窗口应用场景"></a>滑动窗口应用场景</h2><p>滑动窗口算法是一种非常实用的算法技术，它在处理数组或字符串等序列数据时特别有用。以下是一些滑动窗口算法的应用场景：</p><ol><li><p><strong>寻找子数组&#x2F;子串的最小&#x2F;最大和</strong>：</p><ul><li>给定一个数组和一个整数k，找出所有长度为k的子数组的最大和或最小和。</li><li>给定一个数组和一个目标和，找出具有最大和的连续子数组。</li></ul></li><li><p><strong>寻找满足条件的子数组</strong>：</p><ul><li>如前所述，寻找满足总和大于等于某个特定值的最小长度子数组。</li><li>寻找数组中所有等于目标和的子数组。</li></ul></li><li><p><strong>字符串处理</strong>：</p><ul><li>找出字符串中不包含重复字符的最长子串。</li><li>找出字符串中满足特定条件的最短子串，例如包含所有特定字符的最短子串。</li></ul></li><li><p><strong>数据流问题</strong>：</p><ul><li>在处理数据流时，滑动窗口可以用来维护一个固定大小的数据窗口，以便于实时计算窗口内数据的统计信息。</li></ul></li><li><p><strong>时间序列分析</strong>：</p><ul><li>在金融领域，滑动窗口可以用来分析特定时间段内的股票价格变动。</li></ul></li><li><p><strong>滑动窗口协议</strong>：</p><ul><li>在计算机网络中，滑动窗口协议用于控制数据传输，确保接收方不会因为数据量过大而处理不过来。</li></ul></li><li><p><strong>图像处理</strong>：</p><ul><li>在图像处理中，滑动窗口可以用来识别图像中的特定模式或特征。</li></ul></li><li><p><strong>机器学习特征提取</strong>：</p><ul><li>在机器学习中，滑动窗口可以用来从时间序列数据中提取特征。</li></ul></li><li><p><strong>游戏开发</strong>：</p><ul><li>在游戏开发中，滑动窗口可以用来检测玩家在一定时间内的行为模式。</li></ul></li><li><p><strong>实时监控系统</strong>：</p><ul><li>在实时监控系统中，滑动窗口可以用来检测异常行为，例如在短时间内的频繁登录尝试。</li></ul></li></ol><p>滑动窗口算法因其简单和高效而在这些场景中被广泛使用。通过维护一个动态的窗口，算法可以在不遍历整个数据集的情况下，快速找到满足特定条件的数据子集。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记录一次context cancel报错问题</title>
      <link href="/2024/12/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1context-cancel%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1context-cancel%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>生产环境数据库日志有大量报错内容为<code>context canceled</code>的记录。</p><h2 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h2><ol><li>根据报错日志，定位到报错<code>context canceled</code>发生在集中在ORM提交事务之前的DDL方法；<br>报错处业务场景:<br>服务为B&#x2F;S架构，数据同步页面后端服务使用golang-Goframe框架开发，数据库为PostgreSQL，服务业务逻辑为首次进入数据同步页面即执行<strong>数据同步</strong>（客户刷新页面并不会触发数据同步，只会显示历史数据），期间批量并发调用数据查询API并将返参更新到数据库中，因执行更新操作之前需要删除数据库原有数据，故整个删除更新操作开启了事务。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tx,err:=g.DB().Begin(ctx)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;&#125;</span><br><span class="line">tx.DB().Model(<span class="string">&quot;table&quot;</span>).Delete(<span class="string">&quot;key = ?&quot;</span>, key)</span><br><span class="line">_, err := tx.DB().Model(<span class="string">&quot;table&quot;</span>).Data(data).Batch(<span class="number">10</span>).Insert()</span><br></pre></td></tr></table></figure></li><li>回溯代码发现<code>Begin(ctx)</code>传入的<code>context</code>是请求handle使用的<code>context</code>,分别开始排查断开handle的原因<ol><li>通过接口测试工具排查接口耗时是否大于接口超时限制；</li><li>通过数据库最大连接数设置，观察活跃连接数排查服务是否存在连接池泄露问题；</li><li>假设是用户主动刷新页面导致连接被关闭；</li></ol></li><li>经测试，在接口返回之前模拟用户刷新操作可复现问题；</li><li>将<code>Begin(ctx)</code>的入参ctx改为通过<code>Background()</code>返回的根上下文，保证程序同步动作不因请求连接断开而结束；</li><li>为减少接口响应时间，还将事务拆分成多个小事务，也尝试使用乐观锁而不是用事务来执行<code>Update</code>操作；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关系数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流的实现方式</title>
      <link href="/2024/12/18/%E9%99%90%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/12/18/%E9%99%90%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="限流目的"><a href="#限流目的" class="headerlink" title="限流目的"></a>限流目的</h2><p>限流是为保护自身系统和下游系统不被高并发流量冲垮，导致系统雪崩等问题。<br>在保证系统可用的情况下尽可能多增加进入的请求，其余的请求在排队等待，或者返回友好提示，保证里面进入系统的用户可以正常使用，防止系统雪崩。</p><h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p><img src="/../assets/tokenBucket.jpg" alt="令牌桶"><br>指定令牌桶的容量并以固定速率往令牌桶放置令牌，客户端请求时，首先查询令牌桶内的令牌数，若大于0则取出一个令牌，服务端正常处理客户端请求，否则服务端拒绝服务。<br>此外，如果令牌放置的速度比客户端请求的速度要快，令牌桶的令牌会一直增加直到令牌占满整个令牌桶。</p><h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h2><p><img src="/../assets/leakyBucket.jpg" alt="漏桶"><br>指定漏桶容量，同时漏桶会以一定速率放行客户端请求，当桶内请求数量累计数量大于桶容量时，请求被拒绝。</p><h2 id="令牌桶和漏桶的区别"><a href="#令牌桶和漏桶的区别" class="headerlink" title="令牌桶和漏桶的区别"></a>令牌桶和漏桶的区别</h2><p><strong>令牌桶</strong><br>    1. 令牌桶令牌数量是按照指定速率增加的；<br>    2. 令牌桶的容量是固定的，但放行（处理请求）的速度不是固定的，理论上支持的最大并发量就是桶内的容量；<br>    3. 系统的负载能力应该与令牌桶的容量以及放置令牌的速率相关；<br><strong>漏桶</strong><br>    1. 客户端请求以任意速率进入漏桶；<br>    2. 漏桶的容量是固定的，放行（处理请求）的速率也是固定的；<br>    3. 系统的负载能力应该与漏桶的放行速率相关；<br>总之，令牌桶在限制请求平均处理速率的基础上还允许突发的流量增加，而漏桶有更强的削峰能力，可以强制限制请求处理的速率，但漏桶出口的速度固定，因为计算性能固定，不能灵活的应对服务动态扩容的场景</p><h2 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h2><p>计数器算法是在一段时间间隔内（时间窗&#x2F;时间区间），处理请求的最大数量固定，超过部分不做处理。<br>例如：限制接口A在单位时间T内的访问次数不能超过X个。</p><ol><li>在每个单位时间T开始时，设置一个计数器counter，每有一个请求，counter就加1，如果counter的值小于X则放行请求，否则拒绝服务；</li><li>每个单位时间T结束时，重置counter。</li></ol><p><strong>计数器算法存在的临界问题</strong><br><img src="/../assets/counterBug_20241220121909.png" alt="临界问题"><br>如果在单位时间T的结束之前的一小段时间和下一个单位时间T开始之后的一小段时间内出现突发流量，理论上系统最大会承载2X个请求，此时流量速率是可能远大于限制的；</p>]]></content>
      
      
      <categories>
          
          <category> 八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在浏览器输入域名并回车会发生哪些事情</title>
      <link href="/2024/11/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E5%9F%9F%E5%90%8D%E5%B9%B6%E5%9B%9E%E8%BD%A6%E4%BC%9A%E5%8F%91%E7%94%9F%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
      <url>/2024/11/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E5%9F%9F%E5%90%8D%E5%B9%B6%E5%9B%9E%E8%BD%A6%E4%BC%9A%E5%8F%91%E7%94%9F%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/</url>
      
        <content type="html"><![CDATA[<h2 id="从TCP-x2F-IP网络模型角度理解"><a href="#从TCP-x2F-IP网络模型角度理解" class="headerlink" title="从TCP&#x2F;IP网络模型角度理解"></a>从TCP&#x2F;IP网络模型角度理解</h2><p>当你在浏览器中输入域名并按下回车键时，会触发一系列的网络活动，涉及到多个TCP&#x2F;IP网络模型中的协议和组件。以下是从浏览器输入域名到访问网页的大致流程，以及涉及的主要网络协议：</p><ol><li>DNS解析（域名系统协议 - DNS）：<br>•  当你在浏览器中输入一个域名时，首先需要将域名解析为IP地址。这通常通过DNS查询完成。<br>•  浏览器会检查本地的DNS缓存，如果没有找到对应的IP地址，它会向配置的DNS服务器发送查询请求。<br>•  DNS服务器会递归查询，直到找到对应的IP地址，并将结果返回给浏览器。</li><li>ARP协议（地址解析协议 - ARP）：<br>•  如果目标服务器与本地设备在同一局域网内，浏览器可能会使用ARP来将目标IP地址解析为MAC地址。</li><li>IP协议（网际协议 - IP）：<br>•  IP协议负责将数据封装成IP数据包，并在网络中传输。它会处理数据包从源到目的地的传输。</li><li>ICMP协议（互联网控制消息协议 - ICMP）：<br>•  如果在传输过程中遇到问题，如目的地不可达，ICMP协议可以用来发送错误消息。</li><li>TCP协议（传输控制协议 - TCP）：<br>•  一旦DNS解析出IP地址，浏览器会使用TCP协议建立到目标服务器的连接。这涉及到三次握手过程：<br>•  客户端发送SYN（同步序列编号）包到服务器。<br>•  服务器响应SYN-ACK（同步和确认）包。<br>•  客户端发送ACK（确认）包，完成握手。</li><li>HTTP&#x2F;HTTPS协议（超文本传输协议&#x2F;安全超文本传输协议）：<br>•  TCP连接建立后，浏览器会发送HTTP（或HTTPS，如果是加密连接）请求到服务器，请求获取网页内容。<br>•  如果是HTTPS连接，还会涉及到SSL&#x2F;TLS协议来建立安全连接，包括证书验证和加密通信。</li><li>FTP&#x2F;SFTP协议（文件传输协议&#x2F;安全文件传输协议）：<br>•  如果请求涉及下载文件，可能会使用FTP或SFTP协议。</li><li>SMTP&#x2F;POP3&#x2F;IMAP协议（简单邮件传输协议&#x2F;邮局协议&#x2F;互联网消息访问协议）：<br>•  如果请求涉及发送或接收电子邮件，可能会使用SMTP、POP3或IMAP协议。</li><li>TCP&#x2F;IP数据传输：<br>•  一旦HTTP请求被发送，服务器会处理请求并返回相应的HTML页面、图片、CSS文件、JavaScript文件等。<br>•  这些响应通过TCP连接传输回浏览器。</li><li>浏览器渲染：<br>•  浏览器接收到数据后，会解析HTML、CSS和JavaScript，并将网页渲染显示给用户。</li></ol><p>TCP&#x2F;IP网络模型通常被分为四层：应用层、传输层、网络层和数据链路层。以下是你提到的协议分别属于网络模型的哪一层：</p><ol><li>应用层：<br>•  DNS（域名系统协议）：负责将域名转换为IP地址。<br>•  HTTP&#x2F;HTTPS（超文本传输协议&#x2F;安全超文本传输协议）：用于客户端和服务器之间的请求和响应消息传输。<br>•  FTP&#x2F;SFTP（文件传输协议&#x2F;安全文件传输协议）：用于文件的传输。<br>•  SMTP&#x2F;POP3&#x2F;IMAP（简单邮件传输协议&#x2F;邮局协议&#x2F;互联网消息访问协议）：用于电子邮件的发送和接收。</li><li>传输层：<br>•  TCP（传输控制协议）：提供可靠的、面向连接的数据传输服务。<br>•  UDP（用户数据报协议）：提供不可靠的、无连接的数据传输服务（虽然UDP没有被提及，但它也是传输层的一个重要协议）。</li><li>网络层：<br>•  IP（网际协议）：负责数据包的寻址和路由。<br>•  ICMP（互联网控制消息协议）：用于发送错误消息和网络查询。</li><li>数据链路层：<br>•  ARP（地址解析协议）：将IP地址解析为MAC地址，用于同一局域网内的设备通信。<br>数据链路层还涉及到其他一些协议和机制，如以太网（Ethernet）用于局域网通信，以及各种网络接口卡（NIC）驱动程序等。</li></ol><h2 id="从云服务分布式部署架构理解"><a href="#从云服务分布式部署架构理解" class="headerlink" title="从云服务分布式部署架构理解"></a>从云服务分布式部署架构理解</h2><p>从浏览器输入域名并回车后的过程会涉及到多个网络协议和组件，具体如下：</p><ol><li>DNS解析：<br>•  首先，浏览器会进行DNS解析，将域名转换为IP地址。如果域名对应的服务是分布式部署的，DNS解析可能返回一个负载均衡器的IP地址，或者根据地理位置或其他策略返回不同区域服务器的IP地址。</li><li>负载均衡：<br>•  四层负载均衡：在IP+端口层面进行请求分发，根据IP地址和端口号将流量导向后端的具体服务器。<br>•  七层负载均衡：在应用层进行请求分发，可以根据URL、主机名等应用层信息将请求路由到不同的处理服务器。<br>•  负载均衡器可以根据不同的策略来分配请求，如轮询、最少连接、源IP散列或加权负载均衡。</li><li>网络协议：<br>•  HTTP&#x2F;HTTPS：用于浏览器与服务器之间的请求和响应消息传输。<br>•  TCP&#x2F;IP：负责数据包的寻址和路由。<br>•  UDP：在需要低延迟或高吞吐量的场景中使用，如实时应用、视频流或DNS查询。</li><li>服务发现与注册：<br>•  在分布式系统中，服务实例需要在服务注册中心注册自己，以便负载均衡器或其他服务能够发现并调用它们。常见的服务注册中心包括ETCD、Consul或Zookeeper。</li><li>服务网关：<br>•  服务网关负责路由、过滤和负载均衡，提供统一的服务入口。例如，Spring Cloud Gateway可以作为服务网关。</li><li>熔断器：<br>•  熔断器如Hystrix或Resilience4j，提供故障时的自动切断机制和降级服务，防止系统雪崩。</li><li>配置管理：<br>•  分布式配置中心如Spring Cloud Config或Apollo，用于统一管理配置信息，支持动态更新配置。</li><li>消息队列：<br>•  消息队列如RabbitMQ、Kafka等，用于异步通信和消息传递。</li><li>缓存和数据库：<br>•  分布式缓存如Redis、Memcached，以及分布式数据库如MySQL集群、Cassandra、HBase等，用于存储和查询数据。<br>通过这些组件和协议的协同工作，分布式系统能够处理大量的并发请求，提供高可用性和可扩展性。</li></ol><h2 id="从HTTP数据报文解析的角度理解"><a href="#从HTTP数据报文解析的角度理解" class="headerlink" title="从HTTP数据报文解析的角度理解"></a>从HTTP数据报文解析的角度理解</h2><ol><li>HTTP 请求<br>客户端发起HTTP请求，包含以下主要部分：<br>HTTP（HyperText Transfer Protocol） 是用于客户端和服务器之间传输超文本数据的协议，广泛用于万维网（Web）中。HTTP 是一种 应用层协议，它依赖于底层的 传输层协议（如 TCP 或 TLS&#x2F;SSL）来实现数据传输。</li></ol><p>HTTP 协议的基本结构</p><p>HTTP 协议是一个 请求-响应协议，它由 客户端（通常是浏览器）发起请求，服务器接收到请求后返回响应。它是无状态的协议，意味着每个请求都是独立的，服务器不维护客户端的状态。</p><ol><li>HTTP 请求</li></ol><p>HTTP 请求由客户端（如浏览器）发起，包含以下主要部分：</p><p>请求行（Request Line）</p><p>请求行由以下三部分组成：<br>    •HTTP 方法：指定请求类型（如 GET、POST、PUT、DELETE 等）。<br>    •请求 URL：指定服务器上的资源路径。<br>    •HTTP 版本：指明客户端支持的 HTTP 协议版本，通常是 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</p><p>例如：</p><p>GET &#x2F;index.html HTTP&#x2F;1.1</p><p>请求头（Request Headers）</p><p>请求头包含客户端的一些信息，如浏览器类型、支持的语言、请求的主机、请求的时间等。常见的请求头包括：<br>    •Host：指定请求的主机和端口号（例如：Host: <a href="http://www.example.com)./">www.example.com）。</a><br>    •User-Agent：客户端应用程序的详细信息（例如浏览器类型）。<br>    •Accept：告诉服务器客户端支持哪些媒体类型（如 text&#x2F;html、application&#x2F;json）。<br>    •Content-Type：请求体的类型（通常用于 POST 请求）。<br>    •Authorization：用于传输认证信息（如用户名和密码）。</p><p>请求体（Request Body）</p><p>请求体主要用于包含客户端向服务器发送的数据，通常在 POST 或 PUT 请求中使用。GET 请求一般没有请求体。</p><ol start="2"><li>HTTP 响应</li></ol><p>HTTP 响应由服务器发出，包含以下主要部分：</p><p>响应行（Response Line）</p><p>响应行由以下三部分组成：<br>    •HTTP 版本：服务器使用的 HTTP 协议版本（例如 HTTP&#x2F;1.1）。<br>    •状态码：表示请求处理的结果（如 200 OK、404 Not Found）。<br>    •状态码描述：对状态码的描述（如 OK、Not Found）。</p><p>例如：</p><p>HTTP&#x2F;1.1 200 OK</p><p>响应头（Response Headers）</p><p>响应头包含服务器返回的一些元数据，如：<br>    •Content-Type：返回的数据类型（如 text&#x2F;html、application&#x2F;json）。<br>    •Content-Length：响应体的长度。<br>    •Set-Cookie：服务器发送的 Cookie 数据，用于会话管理。<br>    •Cache-Control：缓存控制指令（如 no-cache、max-age）。<br>    •Date：响应生成的日期和时间。</p><p>响应体（Response Body）</p><p>响应体包含实际的数据内容，通常是客户端请求的资源（如 HTML 页面、图片、JSON 数据等）。</p><ol start="3"><li>HTTP 方法</li></ol><p>HTTP 支持多种请求方法，常见的包括：<br>    •GET：用于从服务器获取数据。是最常见的 HTTP 请求方法。请求中不会携带请求体。<br>    •POST：用于向服务器发送数据。通常用于表单提交、文件上传等场景。<br>    •PUT：用于更新服务器上的资源。<br>    •DELETE：用于删除服务器上的资源。<br>    •HEAD：类似于 GET，但服务器只返回响应头，不返回响应体。<br>    •OPTIONS：用于获取服务器支持的 HTTP 方法。<br>    •PATCH：用于部分更新资源。</p><ol start="4"><li>HTTP 状态码<br>HTTP 状态码表示服务器对请求的响应状态。常见的 HTTP 状态码可以分为五个类别：</li></ol><p>1xx（信息性状态码）<br>    •100 Continue：客户端可以继续发送请求的其余部分。<br>    •101 Switching Protocols：服务器根据客户端的请求切换协议。</p><p>2xx（成功状态码）<br>    •200 OK：请求成功，通常返回请求的资源。<br>    •201 Created：请求成功并创建了新的资源。<br>    •204 No Content：请求成功，但没有返回内容。</p><p>3xx（重定向状态码）<br>    •301 Moved Permanently：请求的资源已永久移动到新位置。<br>    •302 Found：请求的资源临时移动到新位置。<br>    •304 Not Modified：资源未被修改，客户端可以使用缓存的副本。</p><p>4xx（客户端错误状态码）<br>    •400 Bad Request：请求无效或缺少必需的参数。<br>    •401 Unauthorized：请求要求身份验证。<br>    •403 Forbidden：服务器理解请求但拒绝执行。<br>    •404 Not Found：请求的资源不存在。</p><p>5xx（服务器错误状态码）<br>    •500 Internal Server Error：服务器内部错误，导致无法完成请求。<br>    •502 Bad Gateway：作为网关或代理的服务器收到了无效响应。<br>    •503 Service Unavailable：服务器当前无法处理请求，通常是由于超载或维护。</p><ol start="5"><li>HTTP 的连接管理</li></ol><p>长连接（Keep-Alive）</p><p>HTTP&#x2F;1.0 默认每个请求都建立一次新连接，服务器响应后立即关闭连接。为了优化性能，HTTP&#x2F;1.1 引入了 持久连接（即长连接），在同一 TCP 连接上处理多个请求，避免每次请求都建立新的连接，减少延迟。</p><p>管道化（Pipelining）</p><p>HTTP&#x2F;1.1 支持请求管道化（pipelining），即客户端可以在前一个请求尚未收到响应时，继续发送多个请求。这在减少延迟方面有一定优势，但并非所有服务器都支持。</p><ol start="6"><li><p>HTTP&#x2F;2 和 HTTP&#x2F;3<br> •HTTP&#x2F;2：相较于 HTTP&#x2F;1.1，HTTP&#x2F;2 引入了二进制帧、多路复用、头部压缩等新特性，使得请求和响应更高效，解决了 HTTP&#x2F;1.1 中存在的一些性能瓶颈。HTTP&#x2F;2 采用 二进制协议（而非文本协议）来提高传输效率。<br> •HTTP&#x2F;3：基于 QUIC 协议的 HTTP&#x2F;3 进一步优化了性能，采用 UDP 作为传输层协议，提供更低的延迟和更快的连接建立速度。HTTP&#x2F;3 的核心优势是减少了握手时间，提高了数据传输的稳定性和效率。</p></li><li><p>安全性<br> •HTTPS：HTTP Secure（HTTPS）是通过 TLS&#x2F;SSL 加密的 HTTP 协议，提供数据加密、身份验证和数据完整性，防止中间人攻击和窃听。通过加密的连接，HTTPS 可以确保用户和服务器之间的通信是安全的。</p></li></ol><p>总结</p><p>HTTP 协议是 Web 数据传输的基础，具有简单、灵活和易于实现的特点。虽然 HTTP&#x2F;1.1 已经被广泛使用，现代 Web 中很多应用已经开始采用更高效的 HTTP&#x2F;2 或 HTTP&#x2F;3 协议，以提高性能。通过对 HTTP 协议的理解，我们能够更好地设计和优化 Web 应用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常见八股文</title>
      <link href="/2024/10/06/MySQL%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/10/06/MySQL%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h2><p>一般来说，衡量事务必须满足四个特性：ACID，即 原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><p>原子性（Atomicity）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括<strong>读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</strong>。</p><p>持久性（Durability）：事务处理结束后，对数据的修改就是永久的，会持久化到硬盘上，即便系统故障也不会丢失。</p><h2 id="MySQL事务的隔离级别"><a href="#MySQL事务的隔离级别" class="headerlink" title="MySQL事务的隔离级别"></a>MySQL事务的隔离级别</h2><p>MySQL数据库支持四种事务隔离级别，这些级别定义了在并发环境下事务如何相互隔离，以避免不同类型的事务并发问题，如脏读、不可重复读和幻读。以下是四种事务隔离级别及其描述：</p><ol><li><p>READ UNCOMMITTED（读未提交）：<br>•  在这个级别下，事务可以读取到其他事务未提交的数据。这意味着可能会读到脏数据，因为其他事务可能最终会回滚。<br>•  脏读：可以读取到其他事务未提交的数据。<br>•  不可重复读：可能。<br>•  幻读：可能。</p></li><li><p>READ COMMITTED（读已提交）：<br>•  事务只能读取到其他事务已经提交的数据。这是大多数数据库系统的默认隔离级别。<br>•  脏读：不可能。<br>•  不可重复读：可能。<br>•  幻读：可能。</p></li><li><p>REPEATABLE READ（可重复读）：<br>•  事务在整个过程中可以多次读取到相同的数据集。这是MySQL的默认隔离级别（对于InnoDB存储引擎）。<br>•  脏读：不可能。<br>•  不可重复读：不可能。<br>•  幻读：可能（在MySQL中，REPEATABLE READ隔离级别实际上防止了幻读，因为它使用Next-Key Locks）。</p></li><li><p>SERIALIZABLE（串行化）：<br>•  这是最高的隔离级别，事务会完全隔离，事务会依次顺序执行，模拟了事务串行执行的场景。<br>•  脏读：不可能。<br>•  不可重复读：不可能。<br>•  幻读：不可能。</p></li></ol><p>在MySQL中，可以通过以下SQL语句查看和设置事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前会话的事务隔离级别：</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx_isolation</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看全局事务隔离级别：</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.tx_isolation;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置当前会话的事务隔离级别：</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL [隔离级别];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置全局事务隔离级别：</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL [隔离级别];</span><br></pre></td></tr></table></figure><p>其中[隔离级别]可以是READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ或SERIALIZABLE中的一个。需要注意的是，更改全局事务隔离级别可能需要具有相应的权限，并且在某些情况下，更改可能不会立即生效，因为MySQL可能需要重启才能应用新的全局设置。</p><h2 id="不可重复读和幻读对事务隔离性的影响"><a href="#不可重复读和幻读对事务隔离性的影响" class="headerlink" title="不可重复读和幻读对事务隔离性的影响"></a>不可重复读和幻读对事务隔离性的影响</h2><p>在数据库事务中，不可重复读（No-repeatable Read）和幻读（Phantom Read）是两种不同的并发问题，它们对事务的隔离性有不同的影响。<br>不可重复读（Non-repeatable read）是数据库事务中的一个并发问题，指的是在一个事务内，多次读取同一数据集合时，由于其他事务的干扰，读取到的结果不一致。<br>对事务隔离性的影响：<br>•  防止不可重复读：在可重复读隔离级别下，事务可以保证在整个事务期间对数据的读取是一致的，即使其他事务对数据进行了修改。<br>•  锁机制：为了实现可重复读，数据库通常会使用行级锁或间隙锁（Gap Locks）来防止其他事务修改或插入那些被当前事务读取的数据行。<br>幻读（Phantom Read）<br>幻读是指在一个事务内，第一次查询某条记录时不存在，但在后续的查询中却出现了，就像“幻影”一样。这通常是因为其他事务插入了新的记录，而这些记录符合当前事务的查询条件。<br>对事务隔离性的影响：<br>•  影响数据一致性：幻读可能会导致事务在逻辑上的数据不一致，尤其是在涉及范围查询和计数的场景中。<br>•  防止幻读的机制：为了防止幻读，数据库需要使用更复杂的锁机制，如Next-Key Locks（行锁和间隙锁的组合），这样可以锁定一个范围，防止其他事务在这个范围内插入新的记录。<br>对事务隔离性的影响总结<br>•  可重复读：提高了事务的隔离性，使得事务在执行期间能够看到一致的数据视图，但可能会因为锁的使用而降低并发性。<br>•  幻读：降低了事务的隔离性，因为它允许其他事务在当前事务执行期间插入新的记录，这可能会导致当前事务的逻辑错误。<br>在实际应用中，不同的数据库管理系统对于可重复读和幻读的处理方式可能有所不同。例如，MySQL的InnoDB存储引擎在可重复读隔离级别下通过Next-Key Locks机制来防止幻读，而其他数据库可能需要更高的隔离级别（如串行化）来防止幻读。选择合适的隔离级别需要在数据一致性和系统并发性之间做出权衡。</p><h2 id="MySQL的存储引擎有哪些"><a href="#MySQL的存储引擎有哪些" class="headerlink" title="MySQL的存储引擎有哪些"></a>MySQL的存储引擎有哪些</h2><p>MySQL支持多种存储引擎，每种存储引擎都有其独特的特点和适用场景。以下是一些常用的MySQL存储引擎及其使用场景：</p><ol><li>InnoDB存储引擎：<br>•  特点：支持事务处理、行级锁定和外键约束，适合需要高并发和数据一致性的应用。<br>•  适用场景：电子商务网站、金融系统等需要事务支持的场景。<br>•  优点：灾难恢复性好、支持事务、使用行级锁、支持外键关联、支持热备份。<br>•  缺点：占用的数据空间相对较大。</li><li>MyISAM存储引擎：<br>•  特点：插入和查询速度快，但不支持事务处理和外键约束，适合读密集型应用。<br>•  适用场景：内容管理系统、日志系统等读多写少的场景。<br>•  优点：读取速度快，不占用大量内存与存储资源。<br>•  缺点：更新机制浪费内存空间，需要依靠OPTIMIZE TABLE来恢复，主机宕机后，MyISAM表易损坏，灾难恢复性不佳。</li><li>Memory存储引擎：<br>•  特点：所有数据存储在内存中，读写速度快，但不支持事务处理和外键约束，数据在数据库重启后会丢失，适合临时数据存储。<br>•  适用场景：会话信息、临时表等需要快速访问的场景。<br>•  优点：提供内存表，显著提高访问数据的速度。<br>•  缺点：服务器重启后数据会丢失，复制维护时需要小心。</li><li>Archive存储引擎：<br>•  特点：提供高压缩存储，适用于存储历史数据或日志数据，只支持最基本的插入和查询功能。<br>•  适用场景：适用于存储历史数据或日志数据的归档。</li><li>CSV存储引擎：<br>•  特点：将数据存储在逗号分隔值的文本文件中，易于导入导出，不支持索引。<br>•  适用场景：数据导入导出，需要将数据存储在可读性强、易编辑的文件中的场景。</li><li>Federated存储引擎：<br>•  特点：允许MySQL服务器访问远程MySQL服务器上的表，类似于分布式数据库。<br>•  适用场景：分布式数据库系统，需要跨多个MySQL服务器访问数据的场景。<br>每种存储引擎都有其特定的优势和限制，选择时应根据具体的业务需求和场景来决定。</li></ol><h2 id="MySQL索引的存储结构为什么是B-树而不是B树"><a href="#MySQL索引的存储结构为什么是B-树而不是B树" class="headerlink" title="MySQL索引的存储结构为什么是B+树而不是B树"></a>MySQL索引的存储结构为什么是B+树而不是B树</h2><p>B树和B+树都是平衡多路查找树，用于索引和存储数据，但它们在数据结构和一些实现细节上有所不同。以下是B树和B+树的主要区别：</p><ol><li>节点结构：<br>•  B树：节点中既包含数据，也包含索引键。每个节点可以包含多个数据项和索引键，数据项和索引键是交替存储的。<br>•  B+树：节点中只包含索引键，不包含数据。数据存储在叶子节点，且叶子节点之间通过指针连接，形成一个链表。</li><li>数据存储位置：<br>•  B树：数据可以存储在树的任何节点中，包括非叶子节点。<br>•  B+树：数据只存储在叶子节点中，非叶子节点仅用于索引。</li><li>查询效率：<br>•  B树：查询可能在非叶子节点结束，因为数据可能存储在非叶子节点。<br>•  B+树：查询必须到达叶子节点，因为所有数据都存储在叶子节点。</li><li>树的高度：<br>•  B树：由于数据分布在所有节点中，树的高度相对较高。<br>•  B+树：由于非叶子节点不存储数据，只存储索引键，树的高度相对较低。</li><li>范围查询：<br>•  B树：进行范围查询时，需要在叶子节点中进行中序遍历。<br>•  B+树：进行范围查询时，可以直接在叶子节点的链表上进行，效率更高。</li><li>磁盘I&#x2F;O：<br>•  B树：由于树的高度较高，磁盘I&#x2F;O次数相对较多。<br>•  B+树：由于树的高度较低，磁盘I&#x2F;O次数相对较少。</li><li>空间利用率：<br>•  B树：节点中存储数据和索引键，空间利用率相对较低。<br>•  B+树：节点中只存储索引键，空间利用率相对较高，可以存储更多的索引键。</li><li>写操作：<br>•  B树：写操作时，可能需要对非叶子节点进行分裂，操作较为复杂。<br>•  B+树：写操作时，只需要对叶子节点进行分裂，操作相对简单。<br>MySQL选择B+树作为索引结构而不是B树，主要有以下几个原因：</li><li>查询性能更优：<br>•  B+树的所有数据都存储在叶子节点中，查询时只需要遍历一次叶子节点即可得到查询结果，而B树的数据既可能存储在非叶子节点中，也可能存储在叶子节点中。B树在查询时需要遍历非叶子节点和叶子节点，效率相对较低。</li><li>磁盘I&#x2F;O次数更少：<br>•  B+树的非叶子节点不存储数据，只存储索引键，因此可以存储更多的索引键，减少了树的高度，使得磁盘I&#x2F;O次数减少，查询更快。</li><li>更适于范围查询：<br>•  B+树的叶子节点通过指针相互连接，形成一个有序链表，方便顺序访问和范围查询。在B树中进行范围查询时，需要对B树进行中序遍历，而B+树的范围查询只需要对链表进行遍历即可。</li><li>查询效率更稳定：<br>•  B树的查询时间复杂度在1到树高之间，分别对应记录在根节点和叶节点，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。</li><li>空间利用率更高：<br>•  由于B+树的非叶子节点不存储数据，只存储索引键，因此在相同磁盘空间下，B+树可以存储更多的索引键，提高了空间利用率。</li><li>更适合外部存储：<br>•  B+树由于内节点无data域，每个节点能索引的范围更大更精确，使得B+树单次磁盘IO的信息量大于B树，从而减少了查询时需要的磁盘IO次数。<br>综上所述，B+树在查询性能、磁盘I&#x2F;O次数、范围查询以及查询效率稳定性方面相较于B树都有显著优势，这些特性使得B+树更适合作为MySQL数据库的索引结构。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关系数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络攻击方式</title>
      <link href="/2024/06/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/06/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的网络攻击方式"><a href="#常见的网络攻击方式" class="headerlink" title="常见的网络攻击方式"></a>常见的网络攻击方式</h2><ol><li>D-Dos攻击，分布式Dos攻击，即大批量请求目标服务器暴露出来的接口，使其无法正常响应其他用户的请求；</li><li>SQL注入；</li><li>DNS欺骗，攻击者伪造DNS响应，将用户重定向到恶意网站；</li><li>中间人攻击（篡改SSL证书，替换加密信息）；</li><li>会话劫持，窃取用户会话标识符，如cookie，接管用户的会话；</li><li>跨站脚本攻击（浏览器跨域校验）；</li><li>端口扫描（Port Scanning）：攻击者扫描网络以查找开放的端口，以确定潜在的入侵点；</li><li>缓冲区溢出攻击，输入的数据超出程序缓冲区的容量，导致程序崩溃或执行攻击者的代码；</li></ol><h2 id="如何预防D-Dos攻击"><a href="#如何预防D-Dos攻击" class="headerlink" title="如何预防D-Dos攻击"></a>如何预防D-Dos攻击</h2><ol><li>ip限制，设置ip白名单；</li><li>ip限流，限制每个ip单位时间内的请求次数；</li><li>加缓存中间件，如redis，消息队列中间件等，避免短时间内大量请求直接访问到数据库；</li><li>接口设计优化，接口涉及IO即访问数据库的尽量不用GET请求，入参校验cookie，或token这些；</li><li>使用高防高IP服务器；</li><li>分布式部署，保证可用性；</li><li>加一层CDN，让CDN抗住攻击；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 网络攻防 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解golang的Context设计</title>
      <link href="/2024/03/25/%E7%90%86%E8%A7%A3golang%E7%9A%84Context%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/03/25/%E7%90%86%E8%A7%A3golang%E7%9A%84Context%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Context的使用场景"><a href="#Context的使用场景" class="headerlink" title="Context的使用场景"></a>Context的使用场景</h2><p>Context的设计初衷就是为了在多个goroutine之间传递和同步取消信号，以减少资源的消耗和占用，具体有以下使用场景：</p><ol><li>作为请求API的调用方&amp;被调用方时的超时控制，通常用于数据库或者网络连接的超时控制；</li><li>作为各协程之间共用的变量池例如Gin框架中各中间件链式调用时互相传递Context；<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Deadline returns the time when work done on behalf of this context </span></span><br><span class="line">    <span class="comment">// should be canceled. </span></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"><span class="comment">// Done returns a channel that&#x27;s closed when work done on behalf of this</span></span><br><span class="line"><span class="comment">// context should be canceled.</span></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// If Done is not yet closed, Err returns nil.</span></span><br><span class="line"><span class="comment">// If Done is closed, Err returns a non-nil error explaining why:</span></span><br><span class="line"><span class="comment">// Canceled if the context was canceled</span></span><br><span class="line"><span class="comment">// or DeadlineExceeded if the context&#x27;s deadline passed.</span></span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line"><span class="comment">// Value returns the value associated with this context for key, or nil</span></span><br><span class="line"><span class="comment">// if no value is associated with key. Successive calls to Value with</span></span><br><span class="line"><span class="comment">// the same key returns the same result.</span></span><br><span class="line">Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Context超时控制的实现原理"><a href="#Context超时控制的实现原理" class="headerlink" title="Context超时控制的实现原理"></a>Context超时控制的实现原理</h2><p>通过<code>Done()</code>传递超时信号，并使用Select监听超时信号是否传入，官方注释如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done is provided for use in select statements:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  // Stream generates values with DoSomething and sends them to out</span></span><br><span class="line"><span class="comment">//  // until DoSomething returns an error or ctx.Done is closed.</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Stream</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- Value)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line"> v, err := DoSomething(ctx)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">select</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"> <span class="keyword">return</span> ctx.Err()</span><br><span class="line"> <span class="keyword">case</span> out &lt;- v:</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Context的Keys池如何保证线程安全"><a href="#Context的Keys池如何保证线程安全" class="headerlink" title="Context的Keys池如何保证线程安全"></a>Context的Keys池如何保证线程安全</h2><p>官方<code>context</code>包下的Context接口内部对Keys没有使用传统锁的机制来保证线程安全，每次对<code>Context</code>的操作都会创建一个新的上下文实例，而不是改变现有的实例（通过<code>WithDeadline()</code>,<code>WithTimeOut()</code>和<code>WithCancle()</code>这些方法派生父节点上下文的副本），这样的设计避免了对共享资源的直接修改，从而避免了锁的需要。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gin框架实现的<code>Context</code>内部是通过读写锁保证Key-Value变量池的线程安全</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set is used to store a new key/value pair exclusively for this context.</span></span><br><span class="line"><span class="comment">// It also lazy initializes  c.Keys if it was not used previously.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Set(key <span class="type">string</span>, value any) &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.Keys == <span class="literal">nil</span> &#123;</span><br><span class="line">c.Keys = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]any)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Keys[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the value for the given key, ie: (value, true).</span></span><br><span class="line"><span class="comment">// If the value does not exist it returns (nil, false)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Get(key <span class="type">string</span>) (value any, exists <span class="type">bool</span>) &#123;</span><br><span class="line">c.mu.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">value, exists = c.Keys[key]</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录设计验权系统时的一些随想</title>
      <link href="/2023/08/17/%E8%AE%B0%E5%BD%95%E8%AE%BE%E8%AE%A1%E9%AA%8C%E6%9D%83%E7%B3%BB%E7%BB%9F%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9A%8F%E6%83%B3/"/>
      <url>/2023/08/17/%E8%AE%B0%E5%BD%95%E8%AE%BE%E8%AE%A1%E9%AA%8C%E6%9D%83%E7%B3%BB%E7%BB%9F%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9A%8F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="OAuth2-0协议内容"><a href="#OAuth2-0协议内容" class="headerlink" title="OAuth2.0协议内容"></a>OAuth2.0协议内容</h2><p>OAuth 2.0 是一个行业标准的协议，用于授权。它允许第三方应用获取有限的访问权限，而无需将用户名和密码提供给第三方应用。OAuth 2.0 专注于客户端开发者的简易性，同时为Web应用、桌面应用、手机和起居室设备提供专门的认证流程。以下是 OAuth 2.0 协议的核心内容和组成部分：</p><ol><li>角色：<br>•  资源所有者（Resource Owner）：能够授权访问其资源的用户。<br>•  资源服务器（Resource Server）：存储受保护资源的服务器，只有经过授权的客户端才能访问。<br>•  客户端（Client）：请求访问受保护资源的应用程序。<br>•  授权服务器（Authorization Server）：负责颁发访问令牌给客户端。</li><li>流程：<br>•  授权码模式（Authorization Code Grant）：客户端引导资源所有者至授权服务器，用户登录并授权后，授权服务器返回一个授权码给客户端，客户端使用该码换取访问令牌。<br>•  密码模式（Resource Owner Password Credentials Grant）：客户端直接使用资源所有者的用户名和密码向授权服务器申请访问令牌。<br>•  客户端模式（Client Credentials Grant）：客户端直接向授权服务器申请访问令牌，适用于客户端代表自己访问资源的场景。<br>•  隐式模式（Implicit Grant）：适用于纯前端应用，客户端引导资源所有者至授权服务器，用户授权后，授权服务器直接返回访问令牌给客户端。<br>•  设备模式（Device Authorization Grant）：适用于无法通过常规流程进行用户交互的设备，例如物联网设备。</li><li>令牌：<br>•  访问令牌（Access Token）：允许客户端访问受保护资源的令牌。<br>•  刷新令牌（Refresh Token）：用于获取新的访问令牌，通常在访问令牌过期后使用。</li><li>安全性：<br>•  OAuth 2.0 要求使用HTTPS来保护所有OAuth流程中的通信，以防止令牌被截获。<br>•  访问令牌和刷新令牌应该是随机的、不可预测的，并且具有足够的长度。<br>•  客户端必须验证授权服务器的重定向URI。</li><li>扩展性：<br>•  OAuth 2.0 支持多种扩展，例如开放ID连接（OpenID Connect），它允许在OAuth 2.0授权过程中传递用户身份信息。<br>OAuth 2.0 协议是复杂的，并且需要根据具体的应用场景和安全要求来正确实施。它旨在提供一个安全、灵活且可扩展的授权框架，以满足不同应用的需求。</li></ol><h2 id="JWT和Cookie的使用场景差异"><a href="#JWT和Cookie的使用场景差异" class="headerlink" title="JWT和Cookie的使用场景差异"></a>JWT和Cookie的使用场景差异</h2><p>JWT（JSON Web Tokens）和Cookie是两种不同的技术，它们在Web应用中用于身份验证和信息传递，但它们之间存在一些关键的区别：</p><ol><li>存储位置：<br>•  Cookie：存储在客户端浏览器中，由浏览器自动处理。<br>•  JWT：可以存储在客户端（通常作为URL的一部分、存储在Cookie中或者LocalStorage&#x2F;SessionStorage中），也可以存储在服务端。</li><li>安全性：<br>•  Cookie：可以设置为仅通过HTTPS传输（Secure标志），并且可以设置HttpOnly标志，使得JavaScript无法访问，减少XSS攻击的风险。<br>•  JWT：本身是自包含的，包含所有必要的信息，因此不需要在服务器上存储会话信息。但是，JWT需要通过HTTPS传输以防止中间人攻击，且应使用强算法（如RS256）签名以防止篡改。</li><li>大小：<br>•  Cookie：大小受限（通常每个域名限制为20-30个Cookie，每个Cookie大小限制在4KB左右）。<br>•  JWT：理论上可以更大，但因为需要在HTTP请求头中传输，所以也不宜过大，以免影响性能。</li><li>性能：<br>•  Cookie：每次请求都会自动发送，可能会增加请求的大小，但不需要修改HTTP请求头。<br>•  JWT：需要在每次请求的HTTP头中明确指定，可能会增加请求头的大小，但不需要在服务器上查找会话信息。</li><li>会话管理：<br>•  Cookie：依赖于服务器端的会话存储，可以很容易地实现会话的注销和失效。<br>•  JWT：由于是自包含的，不需要服务器存储会话信息，但一旦发出，除非过期，否则不能轻易撤销。</li><li>跨域访问：<br>•  Cookie：受到同源策略的限制，不能跨域访问。<br>•  JWT：由于是作为请求的一部分发送，可以跨域使用。</li><li>用途：<br>•  Cookie：主要用于跟踪会话状态，也可以用于存储用户偏好等信息。<br>•  JWT：主要用于身份验证和信息交换，尤其是在分布式系统中。<br>总的来说，Cookie更适合用于会话管理，而JWT更适合用于分布式系统中的身份验证和信息交换。选择使用哪种技术取决于具体的应用场景和需求。</li></ol><h2 id="JWT-Json-Web-Tokens-包含哪些信息"><a href="#JWT-Json-Web-Tokens-包含哪些信息" class="headerlink" title="JWT(Json Web Tokens)包含哪些信息"></a>JWT(Json Web Tokens)包含哪些信息</h2><p>JWT（JSON Web Tokens）是一种紧凑且自包含的方式，用于在各方之间以JSON对象的形式安全地传输信息。JWT通常包含三个部分，用点.分隔，分别是Header（头部）、Payload（负载）和Signature（签名）。下面是每个部分通常包含的信息：</p><ol><li>Header（头部）：<br>•  typ：类型，通常为JWT。<br>•  alg：指定签名算法，如HS256（HMAC SHA-256）或RS256（RSA签名）。</li><li>Payload（负载）：<br>•  iss：发行人（Issuer），指的是token签发的主体。<br>•  exp：过期时间（Expiration Time），token的有效期。<br>•  iat：发行时间（Issued At），token签发的时间。<br>•  nbf：生效时间（Not Before），token在此时间前不可用。<br>•  sub：主题（Subject），通常指用户的唯一标识。<br>•  aud：受众（Audience），token的预期接收者。<br>•  jti：JWT ID，提供token的唯一标识，防止重复使用。<br>•  自定义声明：除了以上标准声明外，还可以包含其他业务相关的自定义声明。</li><li>Signature（签名）：<br>•  签名部分是由Header指定的算法、一个秘密（对于HS算法）或公钥&#x2F;私钥对（对于RS或ES算法）以及Header和Payload的编码后的字符串组成的。签名用于验证消息在传输过程中未被篡改，并且，对于使用私钥签名的token，还可以验证发送者的身份。<br>JWT的结构如下所示：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Header&gt;.&lt;Payload&gt;.&lt;Signature&gt;</span><br></pre></td></tr></table></figure></li></ol><p>•  Header和Payload通常使用Base64Url编码。<br>•  Signature是使用Header中指定的算法和密钥对Header和Payload的编码字符串进行签名的结果。<br>JWT的设计目的是在各方之间安全地传输信息，同时确保信息的完整性和可验证性。由于JWT可以包含敏感信息，因此在使用JWT时，必须通过HTTPS等安全协议传输，以防止中间人攻击。</p><h2 id="使用哈希加密算法加密保存敏感信息的一些注意事项"><a href="#使用哈希加密算法加密保存敏感信息的一些注意事项" class="headerlink" title="使用哈希加密算法加密保存敏感信息的一些注意事项"></a>使用哈希加密算法加密保存敏感信息的一些注意事项</h2><p>使用哈希加密算法加密保存敏感信息时，需要注意以下几个重要的事项：</p><ol><li>选择合适的哈希算法：<br>•  应使用当前认为安全的哈希算法，如SHA-256或SHA-512，避免使用已不安全的算法，如MD5和SHA-1。</li><li>盐值的使用：<br>•  为了防止彩虹表攻击，每个密码在哈希前应该加上一个唯一的盐值。盐值可以增加密码破解的难度。</li><li>哈希输出长度：<br>•  哈希输出应足够长（建议256位以上），以防止暴力破解和生日攻击。</li><li>安全存储哈希和盐值：<br>•  存储哈希值时，应将盐值与哈希值一起存储，但盐值本身不需要保密。</li><li>避免时序和功耗分析攻击：<br>•  使用恒定时间和随机化哈希算法，以防止通过分析算法执行来破解哈希值。</li><li>密码轮换和多因素身份验证：<br>•  在遭受攻击后，仅存储哈希值是不够的。应采用密码轮换和多因素身份验证。</li><li>数据传输安全：<br>•  敏感数据的传输应通过安全的通信通道（如HTTPS&#x2F;TLS）进行，以防止中间人攻击。</li><li>使用最新的安全标准：<br>•  加密与哈希算法不断发展，应定期更新应用程序，使用最新的安全标准和库。</li><li>密码存储格式：<br>•  一些哈希算法（如bcrypt）的哈希值包含了算法标识、成本因子和盐值，这些信息都嵌入在哈希值中，无需单独存储。</li><li>密码长度限制：<br>•  某些哈希算法（如bcrypt）对密码长度有限制，若密码超出此限制，需要进行额外处理。</li><li>不可逆性：<br>•  哈希算法的设计理念和加密原理确保了它在密码保护中的不可替代性。通过盐、成本因子以及不可逆的特性，可以有效抵御暴力破解和彩虹表攻击。</li><li>安全开发实践：<br>•  采用安全的开发实践对于保障敏感信息的安全至关重要，包括进行代码审查、定期的安全培训、漏洞扫描等。<br>遵循这些注意事项可以帮助提高敏感信息的安全性，保护用户数据免受恶意攻击。</li></ol><h2 id="MD5保存密码为什么不够安全了，SHA-256相比MD5有什么优势"><a href="#MD5保存密码为什么不够安全了，SHA-256相比MD5有什么优势" class="headerlink" title="MD5保存密码为什么不够安全了，SHA-256相比MD5有什么优势"></a>MD5保存密码为什么不够安全了，SHA-256相比MD5有什么优势</h2><p>MD5不如SHA-256安全的原因主要包括以下几点：</p><ol><li>哈希长度：<br>•  MD5产生128位的哈希值，而SHA-256产生256位的哈希值。更长的哈希值意味着更大的哈希空间，从而使得碰撞的概率更小，提高了安全性。</li><li>抗碰撞性：<br>•  MD5已被证明存在漏洞，容易受到碰撞攻击，即可以找到两个不同的输入值，它们产生相同的MD5哈希值。相比之下，SHA-256对碰撞攻击的抵抗力更强，目前还没有发现有效的攻击方法。</li><li>安全性：<br>•  MD5的安全性较弱，存在已知的漏洞，而SHA-256目前被认为更安全，没有发现严重的漏洞。</li><li>计算性能：<br>•  尽管MD5在计算速度上比SHA-256快，但安全性是更重要的考量因素。SHA-256虽然计算速度较慢，但由于其更长的哈希长度，提供了更高的安全性。</li><li>应用场景：<br>•  SHA-256由于其高安全性，被广泛应用于数字签名、区块链、文件校验等需要高安全性保障的场景。而MD5则更多用于一些对安全性要求不高的场景。</li><li>雪崩效应：<br>•  SHA-256具有高的雪崩效应，即输入的微小变化会导致输出的哈希值发生巨大变化，这增强了其安全性。</li><li>密码学弱点：<br>•  MD5的密码学弱点已经被广泛研究和利用，包括长度扩展攻击和碰撞攻击，而SHA-256在这方面的表现更为稳健。<br>综上所述，SHA-256在安全性、抗碰撞性、输出长度等方面都优于MD5，因此在需要高安全性的应用中，SHA-256是更安全的选择。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> OAuth2.0 </tag>
            
            <tag> 哈希算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPM协程调度模型的工作原理</title>
      <link href="/2023/07/17/%E5%AF%B9GPM%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
      <url>/2023/07/17/%E5%AF%B9GPM%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>理解GPM协程调度模型工作原理之前，先了解下<strong>协程、线程、进程之间的区别：</strong><br>    进程是操作系统进行资源分配的基本单位，线程是CPU调度的基本单位，其中协程相对于CPU调度的线程可以区分为用户态的线程和内核态的线程，实际运行时，CPU仍然只切换内核态的线程，协程可以通过协程调度器，让多个用户态的线程队列和一个CPU轮转期内核态的线程绑定运行也即在用户态实现并发，以达到减少线程切换时CPU资源浪费的目的。<br>协程的目的是在执行多线程任务时，减少CPU在切换线程上的调度消耗，以达到提高CPU的利用率。</p><p>GPM的G是goroutine协程，P是processor处理器是抽象的处理器，包含了协程运行的环境资源，M是Machine线程，内核状态的线程。goroutine相比于广义的协程，占用更小的内存空间，只占几KB的内存（线程占用约4MB，广义协程也是MB级别），调度更加灵活</p><p>G 表示 Goroutine，也就是 Go 语言中的轻量级线程。Goroutine 是一种并发执行的抽象，它比传统的线程更轻量、更高效，并且可以很容易地创建和销毁。</p><p>P 表示 Processor，也可以理解为上下文处理器。每个 P 其实就是一个相当于操作系统线程的抽象，负责执行 Goroutine。P 的个数可以通过 <code>GOMAXPROCS</code> 环境变量或者 <code>runtime.GOMAXPROCS</code> 函数进行设置。</p><p>M 表示 Machine，也就是操作系统线程和内核的直接映射，它负责管理真实的线程资源，并与操作系统进行交互。在 GPM 调度模型中，有多个 M，可以与多个 P 绑定。</p><p>N 表示工作队列的长度。工作队列用来存放待执行的 Goroutine，当某个 P 处于空闲状态时，会从工作队列中取出 Goroutine 执行。</p><p>GPM 调度模型的工作流程如下：</p><ol><li>当创建一个 Goroutine 时，它被放入当前 P 的本地队列（local run queue）中。</li><li>当本地队列为空时，P 会尝试从全局队列（global run queue）中偷取 Goroutine。</li><li>如果全局队列也为空，P 则会去其他空闲的 P 偷取 Goroutine。</li><li>当 P 获取到 Goroutine 后，将其放入自己的本地队列并执行。</li><li>P 执行完毕后，会检查是否需要进行垃圾回收操作。</li><li>若某个 P 长时间没有进展（例如发生了系统调用或者进入了休眠状态），它会释放与之关联的 M，并允许其他 Goroutine 使用。</li><li>被释放的 M 可以绑定到其他的 P，并开始执行新的 Goroutine。</li></ol><p>总结起来，GPM 调度模型通过将 Goroutine 分配给不同的 P 来实现并发执行，同时利用工作队列和偷取策略来平衡负载。这种调度模型在高并发、异步执行的场景下表现出色，使得开发者可以轻松地编写高效、高并发的程序。</p>]]></content>
      
      
      <categories>
          
          <category> 八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试用python实现贪吃蛇</title>
      <link href="/2023/07/01/%E5%B0%9D%E8%AF%95%E7%94%A8python%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/2023/07/01/%E5%B0%9D%E8%AF%95%E7%94%A8python%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/../assets/pythonSnake%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: KEYDOWN.K_ENTER</span><br><span class="line">op0=&gt;operation: 食物刷新</span><br><span class="line">op1=&gt;operation: 控制行进方向</span><br><span class="line">cond1=&gt;condition: 吃到食物?</span><br><span class="line">cond2=&gt;condition: 触碰到边界或身体?</span><br><span class="line">e=&gt;end: Game Over</span><br><span class="line"></span><br><span class="line">st-&gt;op0-&gt;op1-&gt;cond1-&gt;cond2</span><br><span class="line">cond1(yes)-&gt;op0</span><br><span class="line">cond1(no)-&gt;cond2</span><br><span class="line">cond2(yes)-&gt;e</span><br><span class="line">cond2(no)-&gt;op1</span><br></pre></td></tr></table></figure><h3 id="场景元素图"><a href="#场景元素图" class="headerlink" title="场景元素图"></a>场景元素图</h3><p><img src="/../assets/%E5%9C%BA%E6%99%AF%E5%85%83%E7%B4%A0%E5%9B%BE-%E8%B4%AA%E5%90%83%E8%9B%87.png" alt="场景元素图-贪吃蛇"></p><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>方向调整</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>刷新食物位置</p><p>吃到食物</p><p>触碰到边界</p><h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><p>二维画布</p><p>一维蛇</p><p>点食物</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># author：Wangdali time:2021年1月20日16:08:44</span></span><br><span class="line"><span class="comment">#python实现：贪吃蛇</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">游戏玩法：回车开始游戏；空格暂停游戏/继续游戏；方向键/wsad控制小蛇走向</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">思路：用列表存储蛇的身体；用浅色表示身体，深色背景将身体凸显出来；</span></span><br><span class="line"><span class="string">蛇的移动：仔细观察，是：身体除头和尾不动、尾部消失，头部增加，所以，新添加的元素放在列表头部、删除尾部元素；</span></span><br><span class="line"><span class="string">游戏结束判定策略：超出边界；触碰到自己的身体：蛇前进的下一格子为身体的一部分（即在列表中）。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#注：因为在列表中需要频繁添加和删除元素，所以用deque容器代替列表；是因为deque具有高效的插入和删除效率</span></span><br><span class="line"><span class="comment">#初始化蛇，长度为3，放置在屏幕左上角；</span></span><br><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.<span class="built_in">locals</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="comment">#基础设置</span></span><br><span class="line">Screen_Height=<span class="number">720</span></span><br><span class="line">Screen_Width=<span class="number">1280</span></span><br><span class="line">Size=<span class="number">20</span><span class="comment">#小方格大小</span></span><br><span class="line">Line_Width=<span class="number">1</span></span><br><span class="line"><span class="comment">#游戏区域的坐标范围</span></span><br><span class="line">Area_x=(<span class="number">0</span>,Screen_Width//Size-<span class="number">1</span>) <span class="comment">#0是左边界，1是右边界 #注：python中//为整数除法；/为浮点数除法</span></span><br><span class="line">Area_y=(<span class="number">2</span>,Screen_Height//Size-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#食物的初步设置</span></span><br><span class="line"><span class="comment">#食物的分值+颜色</span></span><br><span class="line">Food_Style_List=[(<span class="number">10</span>,(<span class="number">255</span>,<span class="number">100</span>,<span class="number">100</span>)),(<span class="number">20</span>,(<span class="number">100</span>,<span class="number">255</span>,<span class="number">100</span>)),(<span class="number">30</span>,(<span class="number">100</span>,<span class="number">100</span>,<span class="number">255</span>))]</span><br><span class="line"><span class="comment">#整体颜色设置</span></span><br><span class="line">Light=(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">Dark=(<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">Black=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">Red=(<span class="number">200</span>,<span class="number">30</span>,<span class="number">30</span>)</span><br><span class="line">Back_Ground=(<span class="number">40</span>,<span class="number">40</span>,<span class="number">60</span>)</span><br><span class="line"><span class="comment">#文本输出格式设置</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Print_Txt</span>(<span class="params">screen,font,x,y,text,fcolor=(<span class="params"><span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span></span>)</span>):</span><br><span class="line">    <span class="comment">#font.render参数意义：.render（内容，是否抗锯齿，字体颜色，字体背景颜色）</span></span><br><span class="line">    Text=font.render(text,<span class="literal">True</span>,fcolor)</span><br><span class="line">    screen.blit(Text,(x,y))</span><br><span class="line"><span class="comment">#初始化蛇</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_snake</span>():</span><br><span class="line">    snake=deque()</span><br><span class="line">    snake.append((<span class="number">2</span>,Area_y[<span class="number">0</span>]))</span><br><span class="line">    snake.append((<span class="number">1</span>,Area_y[<span class="number">0</span>]))</span><br><span class="line">    snake.append((<span class="number">0</span>,Area_y[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> snake</span><br><span class="line"><span class="comment">#食物设置</span></span><br><span class="line"><span class="comment">#注意需要对食物出现在蛇身上的情况进行判断</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Creat_Food</span>(<span class="params">snake</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    注：randint 产生的随机数区间是包含左右极限的，</span></span><br><span class="line"><span class="string">    也就是说左右都是闭区间的[1, n]，能取到1和n。</span></span><br><span class="line"><span class="string">    而 randrange 产生的随机数区间只包含左极限，</span></span><br><span class="line"><span class="string">    也就是左闭右开的[1, n)，1能取到，而n取不到。randint</span></span><br><span class="line"><span class="string">    产生的随机数是在指定的某个区间内的一个值，</span></span><br><span class="line"><span class="string">    而 randrange 产生的随机数可以设定一个步长，也就是一个间隔。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    food_x=random.randint(Area_x[<span class="number">0</span>],Area_x[<span class="number">1</span>]) <span class="comment">#此处有疑问</span></span><br><span class="line">    food_y=random.randint(Area_y[<span class="number">0</span>],Area_y[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#如果食物出现在蛇上，重来；</span></span><br><span class="line">    <span class="keyword">while</span>(food_x,food_y)<span class="keyword">in</span> snake:</span><br><span class="line">        food_x = random.randint(Area_x[<span class="number">0</span>], Area_x[<span class="number">1</span>])</span><br><span class="line">        food_y = random.randint(Area_y[[<span class="number">0</span>], Area_y[<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">return</span> food_x,food_y</span><br><span class="line"><span class="comment">#食物风格</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Food_Style</span>():</span><br><span class="line">    <span class="keyword">return</span> Food_Style_List[random.randint(<span class="number">0</span>,<span class="number">2</span>)] <span class="comment">#返回随机的分值和颜色</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    pygame.init()</span><br><span class="line">    screen=pygame.display.set_mode((Screen_Width,Screen_Height)) <span class="comment">#初始化一个准备显示的窗口或屏幕</span></span><br><span class="line">    pygame.display.set_caption(<span class="string">&#x27;贪吃蛇&#x27;</span>) <span class="comment">#Set the current window caption</span></span><br><span class="line">    <span class="comment">#得分字体设置</span></span><br><span class="line">    font1=pygame.font.SysFont(<span class="string">&#x27;SimHei&#x27;</span>,<span class="number">24</span>)</span><br><span class="line">    <span class="comment">#GO字体设置</span></span><br><span class="line">    font2 = pygame.font.SysFont(<span class="literal">None</span>, <span class="number">72</span>)</span><br><span class="line">    fwidth, fheight = font2.size(<span class="string">&#x27;GAME OVER&#x27;</span>) <span class="comment">###</span></span><br><span class="line">    <span class="comment">#程序bug修复：如果蛇在向右移动，快速点击分别施加向下、向左的命令，向下的命令会被覆盖，只有向左的命令被接受，直接GameOver</span></span><br><span class="line">    <span class="comment"># b变量为了防止这个情况发生</span></span><br><span class="line">    b=<span class="literal">True</span></span><br><span class="line">    <span class="comment">#蛇</span></span><br><span class="line">    snake=init_snake()</span><br><span class="line">    <span class="comment">#食物</span></span><br><span class="line">    food=Creat_Food(snake)</span><br><span class="line">    food_style=Food_Style()</span><br><span class="line">    <span class="comment">#方向控制</span></span><br><span class="line">    pos=(<span class="number">1</span>,<span class="number">0</span>) <span class="comment">###</span></span><br><span class="line">    <span class="comment">#启动游戏相关变量初始化</span></span><br><span class="line">    game_over=<span class="literal">True</span>  <span class="comment">#结束标志 # 是否开始，当start = True，game_over = True 时，才显示 GAME OVER</span></span><br><span class="line">    game_start=<span class="literal">False</span>    <span class="comment">#开始标志</span></span><br><span class="line">    score=<span class="number">0</span> <span class="comment">#得分</span></span><br><span class="line">    orispeed=<span class="number">0.3</span>  <span class="comment">#蛇初始速度</span></span><br><span class="line">    speed=orispeed  <span class="comment">#蛇速度</span></span><br><span class="line">    last_move_time=<span class="literal">None</span></span><br><span class="line">    pause=<span class="literal">False</span> <span class="comment">#暂停</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span>==QUIT:</span><br><span class="line">                sys.exit()</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span>==KEYDOWN:</span><br><span class="line">                <span class="keyword">if</span> event.key==K_RETURN:</span><br><span class="line">                    <span class="keyword">if</span> game_over:</span><br><span class="line">                        game_start=<span class="literal">True</span></span><br><span class="line">                        game_over=<span class="literal">False</span></span><br><span class="line">                        b=<span class="literal">True</span></span><br><span class="line">                        snake=init_snake()</span><br><span class="line">                        food=Creat_Food(snake)</span><br><span class="line">                        food_style=Food_Style()</span><br><span class="line">                        pos=(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                        <span class="comment">#得分</span></span><br><span class="line">                        score=<span class="number">0</span></span><br><span class="line">                        last_move_time=time.time()</span><br><span class="line">                <span class="keyword">elif</span> event.key==K_SPACE:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> game_over:</span><br><span class="line">                        pause=<span class="keyword">not</span> pause</span><br><span class="line">                <span class="comment">#以下为防止蛇在向右移动时按向左键，导致GameOver</span></span><br><span class="line">                <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_UP,K_w):</span><br><span class="line">                    <span class="keyword">if</span> b <span class="keyword">and</span> <span class="keyword">not</span> pos[<span class="number">1</span>]: <span class="comment">###</span></span><br><span class="line">                        pos=(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">                        b=<span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_DOWN,K_s):</span><br><span class="line">                    <span class="keyword">if</span> b <span class="keyword">and</span> <span class="keyword">not</span> pos[<span class="number">1</span>]:</span><br><span class="line">                        pos = (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                        b = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_LEFT,K_a):</span><br><span class="line">                    <span class="keyword">if</span> b <span class="keyword">and</span> <span class="keyword">not</span> pos[<span class="number">0</span>]:</span><br><span class="line">                        pos = (-<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                        b = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_RIGHT,K_d):</span><br><span class="line">                    <span class="keyword">if</span> b <span class="keyword">and</span> <span class="keyword">not</span> pos[<span class="number">0</span>]:</span><br><span class="line">                        pos = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                        b = <span class="literal">False</span></span><br><span class="line">        <span class="comment">#填充背景色</span></span><br><span class="line">        screen.fill(Back_Ground)</span><br><span class="line">        <span class="comment">###</span></span><br><span class="line">        <span class="comment">#画网格线、竖线</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(Size, Screen_Width, Size):</span><br><span class="line">            pygame.draw.line(screen, Black, (x, Area_y[<span class="number">0</span>] * Size), (x, Screen_Height), Line_Width)</span><br><span class="line">        <span class="comment">#画网格线、横线</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(Area_y[<span class="number">0</span>] * Size, Screen_Height, Size):</span><br><span class="line">            pygame.draw.line(screen, Black, (<span class="number">0</span>, y), (Screen_Width, y), Line_Width)</span><br><span class="line">        <span class="comment">#蛇的爬行过程</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> game_over:</span><br><span class="line">            curTime=time.time()</span><br><span class="line">            <span class="keyword">if</span> curTime-last_move_time&gt;speed: <span class="comment">###</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pause:</span><br><span class="line">                    b=<span class="literal">True</span></span><br><span class="line">                    last_move_time=curTime</span><br><span class="line">                    next_s = (snake[<span class="number">0</span>][<span class="number">0</span>] + pos[<span class="number">0</span>], snake[<span class="number">0</span>][<span class="number">1</span>] + pos[<span class="number">1</span>])</span><br><span class="line">                    <span class="comment">#如果吃到了食物</span></span><br><span class="line">                    <span class="keyword">if</span> next_s==food:</span><br><span class="line">                        snake.appendleft(next_s)</span><br><span class="line">                        score+=food_style[<span class="number">0</span>]</span><br><span class="line">                        speed = orispeed - <span class="number">0.03</span> * (score // <span class="number">100</span>)</span><br><span class="line">                        food = Creat_Food(snake)</span><br><span class="line">                        food_style = Food_Style()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment">#在区域内</span></span><br><span class="line">                        <span class="keyword">if</span> Area_x[<span class="number">0</span>]&lt;=next_s[<span class="number">0</span>]&lt;=Area_x[<span class="number">1</span>] <span class="keyword">and</span> Area_y[<span class="number">0</span>]&lt;=next_s[<span class="number">1</span>]&lt;=Area_y[<span class="number">1</span>] <span class="keyword">and</span> next_s <span class="keyword">not</span> <span class="keyword">in</span> snake:</span><br><span class="line">                            snake.appendleft(next_s)</span><br><span class="line">                            snake.pop()</span><br><span class="line">                        <span class="keyword">else</span> :</span><br><span class="line">                            game_over=<span class="literal">True</span></span><br><span class="line">        <span class="comment">#画食物</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> game_over:</span><br><span class="line">         <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        rect(Surface,color,Rect,width=0)</span></span><br><span class="line"><span class="string">第一个参数指定矩形绘制到哪个Surface对象上</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二个参数指定颜色</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第三个参数指定矩形的范围（left，top，width，height）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第四个参数指定矩形边框的大小（0表示填充矩形）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">例如绘制三个矩形：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pygame.draw.rect(screen, BLACK, (50, 50, 150, 50), 0)</span></span><br><span class="line"><span class="string">    pygame.draw.rect(screen, BLACK, (250, 50, 150, 50), 1)</span></span><br><span class="line"><span class="string">    pygame.draw.rect(screen, BLACK, (450, 50, 150, 50), 10)</span></span><br><span class="line"><span class="string">         &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 避免 GAME OVER 的时候把 GAME OVER 的字给遮住了</span></span><br><span class="line">        pygame.draw.rect(screen, food_style[<span class="number">1</span>], (food[<span class="number">0</span>] * Size, food[<span class="number">1</span>] * Size, Size, Size), <span class="number">0</span>)</span><br><span class="line">        <span class="comment">#画蛇</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> snake:</span><br><span class="line">            pygame.draw.rect(screen, Dark, (s[<span class="number">0</span>] * Size + Line_Width, s[<span class="number">1</span>] * Size + Line_Width,</span><br><span class="line">                                            Size - Line_Width * <span class="number">2</span>, Size - Line_Width * <span class="number">2</span>), <span class="number">0</span>)</span><br><span class="line">        Print_Txt(screen, font1, <span class="number">30</span>, <span class="number">7</span>, <span class="string">f&#x27;速度: <span class="subst">&#123;score // <span class="number">100</span>&#125;</span>&#x27;</span>)</span><br><span class="line">        Print_Txt(screen, font1, <span class="number">450</span>, <span class="number">7</span>, <span class="string">f&#x27;得分: <span class="subst">&#123;score&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="comment">#画GameOver</span></span><br><span class="line">        <span class="keyword">if</span> game_over:</span><br><span class="line">            <span class="keyword">if</span> game_start:</span><br><span class="line">                <span class="comment">#print(&#x27;GameOver&#x27;)</span></span><br><span class="line">                Print_Txt(screen, font2, (Screen_Width - fwidth) // <span class="number">2</span>, (Screen_Height - fheight) // <span class="number">2</span>, <span class="string">&#x27;GAME OVER&#x27;</span>,Red)</span><br><span class="line">        pygame.display.update()</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自娱自乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pygame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang初学笔记</title>
      <link href="/2022/08/05/golang%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/05/golang%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><p><a href="https://go.dev/tour/list">A Tour of Go</a></p><p><a href="https://gobyexample.com/">Go by Example</a></p><p><a href="https://studygolang.gitbook.io/learn-go-with-tests">Learn Go with tests - learn-go-with-tests (gitbook.io)</a></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><a href="https://blog.csdn.net/TCatTime/article/details/119272186"> Go基本数据类型_TCatTime的博客-CSDN博客_go 数据类型</a></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><a href="https://www.qfgolang.com/?special=jichuyufa">Go语言基础语法-Golang基础语法-Golang中国 (qfgolang.com)</a></p><p>声明变量</p><table><thead><tr><th>声明方式</th><th>特点</th></tr></thead><tbody><tr><td>var 数据名称 type</td><td>数据值为默认值</td></tr><tr><td>数据名 :&#x3D;  值</td><td>:&#x3D;让编译器根据值自动判断数据类型）省去关键字var</td></tr></tbody></table><p>变量不可重复声明！</p><p>命名首字母是否大小写决定是否能够跨包调用，包内定义方法的方法名若是大写则表名可以被其他包调用，否则只能包内调用，类名，属性名同理；</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><ol><li><code>import _ &quot;包路径&quot;</code>因为go语言存在不使用即声明或直接导入则无法通过编译的规则，所以为了满足某些情况下仅需要调用某包的init函数的情景，可以进行匿名导入，即在包路径前添加”_ “ ；</li><li><code>import 别名 &quot;包路径&quot;</code>，起别名也是在包路径前添加”别名 “；</li><li><code>import . &quot;包路径&quot;</code>，将包内所有方法导入到本包中，这样调用导入包中方法时，可以直接通过方法名调用；</li></ol><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>在 Go 中枚举常量是使用 iota 枚举器创建的，在功能上，iota 关键字表示从 0 开始的整数常量；在作用上可以简化使用自动递增数字的常量定义，非常方便。</p><p>以前定义一个枚举值：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = 0</span><br><span class="line">    b = 1</span><br><span class="line">    c = 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Go 有了 iota 关键字后：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对应的值结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=0</span><br><span class="line">b=1</span><br><span class="line">c=2</span><br></pre></td></tr></table></figure><p>甚至还可以跳着来：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line"> a = iota</span><br><span class="line"> _</span><br><span class="line"> b</span><br><span class="line"> c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对应的值结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=0</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br></pre></td></tr></table></figure><p>也可以玩出花来：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line"> bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1//x &lt;&lt; y表示x左移y位</span><br><span class="line"> bit1, mask1                           </span><br><span class="line"> _, _                                  </span><br><span class="line"> bit3, mask3                          </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对应的值结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bit0 == 1, mask0 == 0  (iota == 0)</span><br><span class="line">bit1 == 2, mask1 == 1  (iota == 1)</span><br><span class="line">                       (iota == 2, unused)</span><br><span class="line">bit3 == 8, mask3 == 7  (iota == 3)</span><br></pre></td></tr></table></figure><h3 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h3><ol><li><p>用于修饰方法，执行代码时会将defer修饰的方法输出结果依次压入栈中，在执行时完中括号内所有内容后再按出栈顺序输出结果；</p></li><li><p><code>defer</code> 和 <code>return</code>的执行顺序问题：</p><p>结论：同一方法内，被<code>defer</code>修饰的语句，其执行顺序在<code>return</code>动作之后；</p></li></ol><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>[数组长度]type{值}</p><p>若值的个数小于数组长度，则剩余元素默认值为0，若大于则无法通过编译，且不同长度的数组无法互相传递；</p><h3 id="切片-动态数组"><a href="#切片-动态数组" class="headerlink" title="切片(动态数组)"></a>切片(动态数组)</h3><p>​当数组声明时大括号内没有声明数组长度，则数组为动态数组；</p><h5 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h5><ol><li><p>声明方式一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span> </span><br><span class="line">slice2 := []<span class="type">int</span></span><br></pre></td></tr></table></figure><p>声明slice是一个动态数组，但是并没有给slice分配空间，要使用slice1需要先用make([]int, len)为其开辟空间 PS：用:&#x3D; 代替 &#x3D; 则可省略关键字var；</p></li><li><p>声明方式二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>) </span><br></pre></td></tr></table></figure><p>其中len为数组的初始长度；</p></li><li><p>声明方式三：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myArray[] := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; </span><br></pre></td></tr></table></figure></li></ol><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><ol><li><p>传递方式：切片的传递是引用传递，方法内对形参数组元素的修改会生效在实参上，且不同长度的动态数组都可以进行引用传递；</p></li><li><p><code>for range</code> 遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value := <span class="keyword">range</span> slice&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>len()和cap()函数：len()可以获取切片当前长度，cap()可以获取切片当前容量，容量即切片实际开辟空间，长度则为读取切片的索引最大值，且cap也是动态扩容时的cap追加的数量（重要扩容机制）</p></li><li><p><code>append(slice, key)</code>：向切片末尾添加元素；</p></li><li><p>取切片元素 <code>s1 := slice[0:2]</code>，表明取切片的第1至第2个元素并赋值给<code>s1</code>，区间是左闭右开；</p></li><li><p><code>copy(copySlice2, slice1)</code>，将<code>slice1</code>的内容copy到<code>copySlice2</code>中，为值传递</p></li></ol><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h5 id="底层"><a href="#底层" class="headerlink" title="底层"></a><strong>底层</strong></h5><p><a href="https://blog.csdn.net/doreen211/article/details/125804019">GO中对map排序_雨雨不怕雨的博客-CSDN博客_go map 排序</a></p><p>GO语言中，map是哈希表，能够将特定类型的key映射到特定类型的Value上。在查询Map里面的内容时，其时间复杂度为O(1)非常高效。但其存储并不是线性的，遍历输出时，也没有顺序可言。</p><h5 id="声明方式-1"><a href="#声明方式-1" class="headerlink" title="声明方式"></a>声明方式</h5><ol><li><p>声明方式一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap <span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure><p><code>map</code>和<code>slice</code>的特性一致，可以动态开辟空间，声明若采用此方式，则需要通过<code>make(myMap, len)</code>为其开辟空间进行初始化后才能使用；</p></li><li><p>声明方式二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p>其中<code>len</code>可以省略，省略编译器会默认给<code>myMap</code>分配一定空间；</p></li><li><p>声明方式三：</p></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">myMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>: <span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key3&quot;</span>: <span class="string">&quot;value3&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>: <span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key3&quot;</span>: <span class="string">&quot;value3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h5><ol><li><p>传递方式：同切片，为引用传递</p></li><li><p>添加：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myMap[<span class="string">&quot;key1&quot;</span>] = <span class="string">&quot;value1&quot;</span></span><br><span class="line">myMap[<span class="string">&quot;key2&quot;</span>] = <span class="string">&quot;value2&quot;</span></span><br><span class="line">myMap[<span class="string">&quot;key3&quot;</span>] = <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for range遍历</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> myMap&#123;&#125;</span><br><span class="line"><span class="comment">//print</span></span><br><span class="line">printMap(myMap)</span><br></pre></td></tr></table></figure></li><li><p>删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(myMay, <span class="string">&quot;key1&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMap[<span class="string">&quot;key1&quot;</span>] = <span class="string">&quot;value1_new&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>查找：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示map查找</span></span><br><span class="line">val , ok :=cities[<span class="string">&quot;no2&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;找到了  值为%v&quot;</span>,val)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;没有找到&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="struct，封装"><a href="#struct，封装" class="headerlink" title="struct，封装"></a>struct，封装</h3><ol><li><p>给已定义数据类型起别名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="type">int</span></span><br></pre></td></tr></table></figure></li><li><p>定义结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key <span class="type">int</span></span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">    Length <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getter和setter方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key <span class="type">int</span></span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">    Length <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *myStruct)</span></span> GetKey() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Key = &quot;</span> this.Key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *myStruct)</span></span> SetKey(newKey <span class="type">int</span>) &#123;</span><br><span class="line">    this.Key = newKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo := myStruct&#123;Key:<span class="number">11</span>, Value:<span class="string">&quot;test&quot;</span>, Length:<span class="number">10</span>&#125;<span class="comment">//属性名亦可省略不写</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *myStruct)</span></span> Sort()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is Sort of myStruct&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> superStruct <span class="keyword">struct</span>&#123;</span><br><span class="line">    myStruct <span class="comment">//superStruct继承了myStruct的方法</span></span><br><span class="line">    </span><br><span class="line">    Height <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承并重写父类myStruct的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *superStruct)</span></span> Sort()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is Sort of superStruct&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类对象 方式一</span></span><br><span class="line">demo1 := superStruct&#123;myStruct&#123;<span class="number">11</span>,<span class="string">&quot;test&quot;</span>,<span class="number">10</span>&#125;,<span class="number">120</span>&#125;</span><br><span class="line"><span class="comment">//创建子类对象 方式二</span></span><br><span class="line"><span class="keyword">var</span> demo2 superStruct</span><br><span class="line">demo2.Key = <span class="number">11</span></span><br><span class="line">demo2.Value = <span class="string">&quot;test&quot;</span></span><br><span class="line">demo2.Length = <span class="number">10</span></span><br><span class="line">demo2.Height = <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol><li><p><code>interface</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface的本质是一个指针，指向结构体及其内部的函数列表</span></span><br><span class="line"><span class="keyword">type</span> AnimalIf <span class="keyword">interface</span>&#123;</span><br><span class="line">    Sleep()</span><br><span class="line">    Eat()</span><br><span class="line">    GetColor() String<span class="comment">//获取动物颜色</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的类</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;</span><br><span class="line">Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Cat)</span></span> Sleep()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Cat is sleeping&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Cat)</span></span> Eat()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Cat is eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Cat)</span></span> GetColor() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> this.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;</span><br><span class="line">Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Dog)</span></span> Sleep()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Dog is sleeping&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Dog)</span></span> Eat()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Dog is eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Dog)</span></span> GetColor() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> this.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal AnimalIf</span><br><span class="line"><span class="comment">//因为interface本质是指针，所以传值给接口对象时需要用取地址符&amp;</span></span><br><span class="line">animal = &amp;Cat&#123;<span class="string">&quot;Black&quot;</span>&#125;</span><br><span class="line">animal.Sleep()</span><br><span class="line">animal = &amp;Dog&#123;<span class="string">&quot;White&quot;</span>&#125;</span><br><span class="line">animal.Sleep()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">animalSleep</span><span class="params">(animal AnimalIf)</span></span>&#123;</span><br><span class="line">    animal.Sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="万能类型"><a href="#万能类型" class="headerlink" title="万能类型"></a>万能类型</h3><p><code>interface&#123;&#125;</code> : 空接口</p><p>基本数据类型都实现了空接口</p><ol><li><p>作为形参时，可以接收所有类型的参数</p></li><li><p>给<code> interface&#123;&#125;</code>提供 “断言” 的机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value, ok := demo.(<span class="type">string</span>)<span class="comment">//demo是interface类型,返回 value和ok</span></span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;demo is not a string type&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;demo is a string type, value= &quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>变量内置的<code>pair</code>结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span><span class="comment">// a: pair&lt;statictype:int, value:100&gt; </span></span><br><span class="line"><span class="keyword">var</span> demo myStruct = &#123;<span class="number">10</span>,<span class="string">&quot;test&quot;</span>,<span class="number">99.9</span>&#125;<span class="comment">//demo: pair&lt;type:myStruct, value&#123;10,&quot;test&quot;,99.9&#125;&gt;</span></span><br></pre></td></tr></table></figure><p>pair的结构用于断言判断类型</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p><code>defer</code>定义的语句会在程序结束时，即return或panic之前执行，这意味着，即便程序出现error并panic了，也依旧会执行defer语句。如果要判断是因为何种情况要结束程序才执行的<code>defer</code>，则需要通过recover()去捕获panic，若返回值不为nil则说明来自panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;panic occurred:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    err := findErr()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果定义了多个 <code>defer</code> 语句，它们会以逆序执行（Last In First Out，即后入先出）的顺序依次执行。这意味着最后一个定义的 <code>defer</code> 语句将是第一个执行的，并且最先定义的 <code>defer</code> 语句将是最后一个执行的。</p><h3 id="reflct"><a href="#reflct" class="headerlink" title="reflct"></a>reflct</h3><p>反射通过pair获取变量的类型和值。</p><p>方法：</p><ol><li><p><code>reflct.ValueOf()</code></p></li><li><p><code>reflct.TypeOf()</code></p></li></ol><p>使用场景：通过interface{}万能类型接收变量，再通过TypeOf()获得变量的动态类型，并通过ValueOf()获得参数运行时的值。</p><h3 id="Struct-Tag"><a href="#Struct-Tag" class="headerlink" title="Struct Tag"></a>Struct Tag</h3><p>通过<code>reflect.Type</code>获取结构体成员信息<code>reflect.StructField</code>结构中的 Tag 被称为结构体标签（Struct Tag）。结构体标签是对结构体字段的额外信息标签。使用场景有如定义结构体别名，使得在参数绑定时更好的一一对应</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书写格式</span></span><br><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`tag1:&quot;name&quot; tag2:&quot;名字&quot;`</span><span class="comment">//以键值对的方式书写并用反引号括起来</span></span><br><span class="line">    Sex <span class="type">string</span> <span class="string">`tag1:&quot;sex&quot; tag2:&quot;性别&quot;&#x27;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><a href="https://www.liwenzhou.com/posts/Go/14_concurrence/">Go语言基础之并发 | 李文周的博客 (liwenzhou.com)</a></p><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p><code>goroutine</code>是用户态的线程，由Go语言的运行时（runtime）调度完成。</p><h4 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h4><p>在调用函数的时候在前面加上 <code>go</code> 关键字，就可以为函数创建一个<code>goroutine</code>。</p><p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p><h5 id="特殊机制"><a href="#特殊机制" class="headerlink" title="特殊机制"></a>特殊机制</h5><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p><p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup<span class="comment">//sync.WaitGroup可以让main等待所有goroutine结束后再结束main()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line"><span class="keyword">go</span> hello(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="！！！需要注意的点！！！"><a href="#！！！需要注意的点！！！" class="headerlink" title="！！！需要注意的点！！！"></a><strong>！！！需要注意的点！！！</strong></h5><p> 若以闭包的方式运行goroutine时（如下所示）</p><blockquote><p>闭包函数:关于闭包，最简单的描述就是 ECMAScript 允许使用内部函数－－即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。</p><p>也就是说，内部函数会在外部函数返回后被执行。而当这个内部函数执行时，它仍然必需访问其外部函数的局部变量、参数以及其他内部函数。这些局部变量、参数和函数声明（最初时）的值是外部函数返回时的值，但也会受到内部函数的影响。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup<span class="comment">//sync.WaitGroup可以让main等待所有goroutine结束后再结束main()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">10000</span>) <span class="comment">// 计数牌+1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">        &#125;()</span><br><span class="line">&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello main&quot;</span>)</span><br><span class="line">wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">闭包内含有一个作用域外部的变量，所以执行对应goroutine内容时需要再去访问该变量的值，此时该变量作为flag值已经在循环中并行执行了很多次，故绝大多数goroutine取到的变量值都是最后一次循环的变量值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>解决方式：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup<span class="comment">//sync.WaitGroup可以让main等待所有goroutine结束后再结束main()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">10000</span>) <span class="comment">// 计数牌+1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">        &#125;(i) <span class="comment">// 解决方式：显式传递值给匿名函数，避免闭包</span></span><br><span class="line">&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello main&quot;</span>)</span><br><span class="line">wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h5><p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html">深入Golang调度器之GMP模型 - sunsky303 - 博客园 (cnblogs.com)</a></p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p><code>channel</code>用于实现在多个<code>goroutine</code>间进行通信。</p><p>虽然<code>goroutine</code>可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><p>举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure><h5 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h5><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure><p><em><strong>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</strong></em></p><p>创建channel的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><p>channel的缓冲大小是可选的。</p><p>举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure><h5 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h5><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>现在我们先使用以下语句定义一个通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p><strong>发送</strong></p><p>将一个值发送到通道中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure><p><strong>接收</strong></p><p>从一个通道中接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure><p><strong>关闭</strong></p><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><h4 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h4><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</span><br></pre></td></tr></table></figure><p>为什么会出现<code>deadlock</code>错误呢？</p><p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p><p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">ret := &lt;-c</span><br><span class="line">fmt.Println(<span class="string">&quot;接收成功&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h4 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h4><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h5 id="从通道中取值的方式"><a href="#从通道中取值的方式" class="headerlink" title="从通道中取值的方式"></a>从通道中取值的方式</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启goroutine将0~100的数发送到ch中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="type">int</span>, ch2 <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//从通道中取值的方式1</span></span><br><span class="line">i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch2 &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">go</span> f1(ch1)</span><br><span class="line"><span class="keyword">go</span> f2(ch1, ch2)</span><br><span class="line"><span class="comment">//从通道中取值的方式2</span></span><br><span class="line"><span class="keyword">for</span> ret := <span class="keyword">range</span> ch2 &#123;</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker及个人云盘搭建学习笔记</title>
      <link href="/2021/01/05/Docker%E5%8F%8A%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/01/05/Docker%E5%8F%8A%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前几天去朋友家，他给我演示了下云服务器的妙用，只见他轻轻敲出几行命令后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br><span class="line">//安装docker，我的云服务器系统是CentOS 7.5 64位</span><br><span class="line"></span><br><span class="line">docker pull nextcloud</span><br><span class="line">//拉取nextcloud镜像</span><br><span class="line"></span><br><span class="line">docker pull mysql:8.0</span><br><span class="line">//拉取mysql:8.0镜像</span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl enable docker</span><br><span class="line">//设置docker开机自启动</span><br><span class="line"></span><br><span class="line">docker run -d --name mysql     -v document_mysql:/var/lib/mysql     -e MYSQL_ROOT_PASSWORD=pw1     -e MYSQL_DATABASE=nextcloud     -e MYSQL_USER=user     -e MYSQL_PASSWORD=pw2     -p 3306:3306     mysql:8.0</span><br><span class="line">//在名为mysql的容器中启动mysql:8.0，并配置mysql环境变量：；-d 在后台运行容器，并且打印容器id,--name为容器指定一个名称；-volume,-v 绑定一个卷，格式为-v 本地目录:容器目录 或 -v 容器目录；-e 设置环境变量;</span><br><span class="line"></span><br><span class="line">docker run -d --name nextcloud     -v nextcloud:/var/www/html     --link mysql:mysql     -p 8080:80 nextcloud</span><br><span class="line">//在名为nextcloud的容器中启动nextcloud：--link 添加链接到另一个容器；-p 指定端口映射，格式为：主机(宿主)端口:容器端口</span><br></pre></td></tr></table></figure><p>我空空如也的服务器上就装上了可以多用户登陆的”个人网盘“！</p><p><img src="/../assets/5ed42e430e941d699918b0fc777360ed.png" alt="嘿嘿嘿"></p><p>回家后想起他神乎其神的操作，内心久久不能平静，所以自己查询资料做了点小笔记：</p><p>快速搭建私有云盘参考链接：<a href="https://baiyue.one/archives/453.html">https://baiyue.one/archives/453.html</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>基于Go语言开发的开源项目</p><p><strong>术语：</strong></p><table><thead><tr><th align="center">概念</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">Docker 镜像(Images)</td><td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td align="center">Docker 容器(Container)</td><td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td align="center">Docker 客户端(Client)</td><td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td></tr><tr><td align="center">Docker 主机(Host)</td><td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td align="center">Docker Registry</td><td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td></tr><tr><td align="center">Docker Machine</td><td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr><tr><td align="center">Volume(数据卷)</td><td align="left">通过数据卷可以在容器之间实现共享和重用；<br />对数据卷的修改会立马生效(非常适合作为开发环境)；<br />对数据卷的更新,不会影响镜像；<br />卷会一直存在,直到没有容器使用</td></tr></tbody></table><p><strong>和虚拟机的异同：</strong></p><p>相同点：</p><p>虚拟机和Docker同是使用<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/2480791?fr=aladdin">虚拟化技术</a>，来达到在同一平台上配备多个运行环境的目的；</p><p>不同点：</p><ol><li>虚拟机是通过软件模拟当前的硬件环境（硬件资源的虚拟化）来运行一个完整的操作系统，Docker自建的Docker容器（Container）是共用一个系统内核（内核级别的虚拟化）；</li></ol><p><img src="/../assets/8fffe9889eb532b0d541b3fc656db2ea.png" alt="VM vs Docker"></p><ol><li>虚拟机相对Docker非常笨重，因为承载了一个完整的操作系统导致占用硬件资源十分多，启动也很慢，而Docker中每个镜像文件大小十分轻便（MB级别大小），可以做到秒级启动</li></ol><p>参考链接：<a href="https://www.runoob.com/docker/docker-architecture.html">https://www.runoob.com/docker/docker-architecture.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
